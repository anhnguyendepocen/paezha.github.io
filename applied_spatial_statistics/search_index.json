[
["index.html", "Applied Spatial Statistics with R Preface Spatial Analysis and Spatial Statistics Why this Text? Plan Audience Requisites", " Applied Spatial Statistics with R Antonio Paez 2019-01-15 Preface “Patterns cannot be weighed or measured. Patterns must be mapped.” — Fritjof Capra, The Web of Life: A New Scientific Understanding of Living Systems Spatial Analysis and Spatial Statistics The field of spatial statistics has experienced phenomenal growth in the past 20 years. From being a niche subdiscipline in quantitative geography, statistics, regional science, and ecology at the beginning of the 1990s, it is now a mainstay of applications in a multitude of fields, including medical imaging, remote sensing, civil engineering, geology, statistics and probability, spatial epidemiology, end ecology, to name just a few disciplines. The growth in research and applications in spatial statistics has been in good measure fueled by the explosive growth in geotechnologies: technologies for sensing and describing the natural, social, and built environments on Earth. An outcome of this is that spatial data are, to an unprecedented level, within the reach of multitudes. Hardware and software have become cheaper and increasingly powerful, and we have transitioned from a data poor environment (in all respects, but particularly in terms of spatial data) to a data rich environment. Twenty years ago, for instance, technical skills in spatial analysis included tasks such as digitizing. As a Masters student, I spent many boring hours digitizing paper maps before I could do any analysis on our single-seat (and relatively expensive) Geographic Information System (GIS). I was more or less a freak: altough there was an institutional push to adopt GIS, relatively few in my academic environment saw the value of spending hours doing what nowadays we would think of as low-level technical work. Surely, the time of a Master student, let alone a professional researcher or business analyst, is now more valuable than that. Indeed, very little time is spent anymore in such tasks low-level tasks, as data increasingly are collected and disseminated in a digital format. Instead, there is a huge appetite for what could be called the brainware of spatial analysis, the intelligence counterpart of the hardware, software, and data provided by geotechnologies. The contribution of brainware to spatial analysis is to make sense of vast amounts of data, in effect transforming them into information. This information in turn can be useful to understand basic scientific questions (e.g., changes in land cover), to support public policy (e.g., what is the value capture of public infrastructure), and to inform business decisions (e.g., what levels of demand can be expected given the distribution of retail outlets). There are numerous forms of spatial analysis, including normative techniques (such as spatial optimization; see Tong and Murray 2012) and geometric and cartographic analysis (for instance, map algebra; Tomlin 1990). Among these, spatial statistics is one of the key elements in the family of toolboxes for spatial analysis. So what is spatial statistics? Very quickly, I will define spatial statistics as the application of statistical techniques to data that have geographical references - in other words, to the statistical analysis of maps. Like statistics more generally, spatial statistics is interested in hypothesis testing and inference. What distiguishes it as a branch of the broader field of statistics is its explicit interest in situations where data are not independent from each other (like throws of a dice) but rather display systemic associations. These associations, when seen through the lens of cartography, can manifest themselves as patterns of similarities (birds of a feather flock together) or disimilarities (repulsion due spatial competition among firms) - as two common examples of spatial patterns. Spatial statistics covers a broad array of techniques for the analysis of spatial patterns, including testing whether patterns are random or not, and a wide variety of modelling approaches as well. These tools enhance the brainware of analysts by allowing them to identify and possibly model patterns for inferring processes and/or for making spatial predictions. Why this Text? The objective of this book is to introduce selected topics in applied spatial statistics. The foundation for the book are the notes that I have developed over several years of teaching applied spatial statistics at McMaster University. This course is a senior level specialist course for geographers and students in other disciplines who are often working towards specializations in GIS. Over the course of the years, my colleagues at McMaster and I have used at least three different textbooks for teaching spatial statistics. I have personally used McGrew and Monroe (2009) to introduce fundamental statistical concepts to geographers. McGrew and Monroe (currently on a third edition with Lembo) do a fine job of introducing statistics as a tool for decision making, and therefore offer a very valuable resource to study matters of inference, for instance. Many of the examples in the book are geographical; however, the book is relatively limited in its coverage of spatial statistics (particularly models for spatial processes), which is a limitation for teaching a specialist course on this topic. My book of choice early on (approximately between 2003 and 2010) was the excellent book Interactive Spatial Data Analysis by Bailey and Gatrell (1995). A notable aspect of Bailey and Gatrell was that the book was accompanied by a software application to implement the techniques they discussed. I started using their book as a graduate student around 1998, but even then the limitations of the software that accompanied the book were apparent - in particular the absence of updates or a central repository for code. Despite the regretable obsolesence of the software, the book provided, and still does, a very accessible yet rigorous treatment of many topics of interest in spatial statistics. Bailey and Gatrell’s book was, I believe, the first attempt to bridge, on the one hand, the need to teach mid- and upper-level university courses in spatial statistics, and on the other, the challenges of doing so with very specialized texts on this topic, including the excellent but demanding Spatial Econometrics (Anselin 1988), Advanced Spatial Statistics (Griffith 1988), Spatial Data Analysis in the Social and Environmental Sciences (Haining 1990), not to mention Statistics for Spatial Data (Cressie 1993). More recently, as Bailey and Gatrell aged, my book of choice for teaching spatial statistics became O’Sullivan and Unwin’s Geographical Information Analysis (O’Sullivan and Unwin 2010). This book updates some topics that were not covered by Bailey and Gatrell. To give one example, much work happened in the mid- to late-nineties with the development of local forms of spatial analysis, including Getis and Ord pioneering research on concentration statistics (Getis and Ord 1992), Anselin’s Local Indicators of Spatial Association (Anselin 1995), and Brunsdon, Fotheringham, and Charlton’s research on geographically weighted regression (C. Brunsdon, Fotheringham, and Charlton 1996). These and related local forms of spatial analysis have become hugely influential in the intervening years, and are duly covered by O’Sullivan and Unwin in a way that merges well with a course focusing on spatial statistics - although other specialist texts also exist that delve in much more depth into this topic (e.g., Fotheringham and Brunsdon 1999; and Lloyd 2010). These resources, and many more, have proved invaluable for my teaching for the past few years, and I believe that their influence will be evident in the present book. Other excellent sources are also available, including Applied Spatial Data Analysis in R (Bivand, Pebesma, and Gómez-Rubio 2008), Spatial Data Analysis in Ecology and Agriculture Using R (Plant 2012), An Introduction to R for Spatial Analysis &amp; Mapping (Chris Brunsdon and Comber 2015), Spatial Point Patterns: Methodology and Applications with R (Baddeley, Rubak, and Turner 2016), and Geocomputation with R (Lovelace, Nowosad, and Muenchow 2019). This is in addition to other resources available online, such as M. Gismond’s Intro to GIS and Spatial Analysis and R. Hijmans’s Spatial Data Analysis and Modeling with R. So, if there are some excellent resources for teaching and learning spatial statistics, why am I moved to unleash on the world yet another text on this topic? I am convinced that there is richness in variety. As demand for training in spatial statistics grows, there is potential for different sources to satisfy different needs. Some books are geared to specialized topics (e.g., point pattern analysis; Baddeley, Rubak, and Turner 2016) and are more useful as a reference or a tool for learning for researchers and graduate students. Other books focus more heavily on mapping in R than a course on spatial statistics can comfortably accommodate (e.g., Chris Brunsdon and Comber 2015; Lovelace, Nowosad, and Muenchow 2019). Other books are geared towards specific disciplines (e.g., ecology and agriculture; Plant 2012). Bivand et al. (2008) is an excellent reference. At the time of writing, much work was devoted to issues of spatial data representation. As a consequence, a good portion of their book is concerned with the critical issue of handling spatial data, including data classes and import/export operations. My approach can be seen as complementary to some of the texts above. I have tried to write a text that introduces in (what I hope!) is an intuitive way key concepts of data handling and mapping in R as they are needed to learn and practice spatial statistical analysis. In this way, I can concentrate instead in introducing (again, in what I hope is an intuitive way!) key concepts in spatial statistics. The text is not meant to be used as a reference, although some lectors may find that it works in that way in particular with respect to the implementation of techniques. Rather, the text is more suitable to be read linearly - indeed as a course on the topic of spatial statistics. Readers who have familiarized themselves with the text can possibly find it useful as a reference, but I do not recommend using it as a reference in the first place. Lastly, the focus of the text is on applied spatial statistics. There is, inevitably, a component of math, but I have tried, to the extent of my ability, to make the underlying math as intuitive and accessible as possible. There is also an important computational component - in particular, as per the title, using the R statistical language. As McElreath (2016) notes, in addition to the pedagogical value of teaching statistics using a coding approach, much of statistics has in fact become so computational that coding skills are increasingly indispensable. I tend to agree with this, and there are reasons to believe that one of the strenghts of this approach as well is to make statistical work as open, clear, and reproducible as possible (see Rey 2009). Plan My aim with this book is to introduce key concepts and techniques in the statistical analysis of spatial data in an intuitive way. While there are more advanced treatments of many of these topics, this book should be appealing to students or others who are approaching this topic for the first time. The book is organized thematically following the cannonical approach seen, for instance, in Bailey and Gatrell (1995), Bivand et al. (2008), and O’Sullivan and Unwin (2010). This approach is to conceptualize data by their unit of support. Accordingly, data are seen as being represented by: Discrete processes in space (e.g., points and events). Aggregations into zones for statistical purposes (e.g. demographic variables into census areas). As discrete measurements in space of an underlying continuous process (e.g. weather stations monitoring temperature) Each chapter covers a topic that builds on previous material. Chapters are followed by an activity. I have used the materials presented in this texts (in different incarnations) for teaching spatial data analysis in different settings. Primarily, these notes have been used in the course GEOG 4GA3 Applied Spatial Statistics at McMaster University. This course is a full (Canadian) academic term, which typically means 13 weeks of classes. The course is organized as a 2-hour per week class, with a GIS-lab component which uses a complementary set of notes. For this reason, each chapters is designed to cover very approximately the material that I am used to cover in a 50 minutes lecture in a traditional classroom-lecturing setting. In this case, the activities that follows each chapter could be assigned as homework, optional materials, or as lab materials. For instructors who do not have a lab component, the activities could easily be adapted as lab exercises. More recently, I have experimented flipping the classroom (see here for a discussion of flipped classrooms). Briefly, a flipped classroom changes the role of the instructor and the delivery of contents. In a flipped classroom, the instructor minimizes lecturing time, opting instead for offering study materials in advance (often the materials are online and may have an interactive component). This frees the instructor from the tyranny of lecturing, so that in-class time can be dedicated instead to hands-on activities. The instructor is no longer a source of statistical wisdom, but rather a partner in the learning process. Under this scenario, students are responsible for reading a chapter in advance to a class. The class then is dedicated to the activity that follows the chapter, with students working individually or in small groups in the activity. I have broken a 50-minutes session of this type as follows: 10 minutes to discuss any questions about the preceding reading/study materials, followed by 30 minutes to complete the activity, during which time I engage individually or in small groups with the students as they work, and then at the end a 10 minute recap, where I summarize the key aspects of the lesson, clearly identify the threshold concepts covered, and indicate how this relates to the next lesson. In addition to the two formats above (traditional classroom-lecture and flipped classroom), I have also used portions of these notes to teach short courses in different places (e.g., the University of Western Australia and the Gran Sasso Scientific Institute). The materials can, with some relatively minor modifications, be used in this way. As I continue to work on these notes, I hope to be able to add optional (or bonus) chapters, that could be used 1) to extend a course on spatial statistics beyond the 13 week horizon of the Canadian term, or 2) to offer more advanced material to interested readers. Audience The notes were designed for a course in geography, but in fact, could be easily adjusted to an audience of earth scientists, environmental scientists, econometricians, planners, or students of other disciplines who have an interest in and work with georeferenced datasets. The prerequisites are an introductory college/university level course on multivariate statistics, ideally covering the fundamentals of probability, hypothesis testing, and multivariate linear regression analysis. Requisites To fully benefit from this text, up-to-date copies of R and RStudio are highly recommended. Many examples in the text use datasets that have been packaged for convenience as an R package. To install the package (geog4ga3) use the following command(which requires devtools): library(devtools) devtools::install_github(&quot;paezha/Spatial-Statistics-Course&quot;, subdir = &quot;geog4ga3&quot;) The source files for the chapters and activites can be obtained from the following GitHub repository: https://github.com/paezha/paezha.github.io/tree/master/applied_spatial_statistics It is also possible to suggest edits to the text, and it only requires a GitHub account (sign-up at github.com). After logging into GitHub, you can click on the ‘edit me’ icon (the fourth icon on the left top corner of the toolbar at the top). References "],
["preliminaries-installing-r-and-rstudio.html", "Chapter 1 Preliminaries: Installing R and RStudio 1.1 Introduction 1.2 Learning Objectives 1.3 R: The Open Statistical Computing Project 1.4 Packages in R", " Chapter 1 Preliminaries: Installing R and RStudio 1.1 Introduction Statistical analysis is the study of the properties of a dataset. There are different aspects of statistical analysis, and they often require that we work with data that are messy. According to Wickham and Grolemund (2016), computer-assisted data analysis includes the steps outlined in Figure 1.1. First, the data are imported to a suitable software application. This can include data from primary sources (suppose that you collected coordinates using a GPS) or from secondary sources (the Census of Canada). Data will likely be text tables, or an Excel file, among other possible formats. Before data can be analyzed, they need to be tidied. This means that the data need to be arranged in such a way that they match the process that you are interested in. For instance, a travel survey can be organized so that each row is a traveler, or as an alternative so that each row is a trip. Once that data are tidy, Exploratory Data Analysis (EDA) and/or its geographical extension Exploratory Spatial Data Analysis (ESDA) can be conducted. This involves transforming the raw data into information. Examples of transformations include calculating the mean and the standard deviation. Visualization is also part of this exploratory exercise. In EDA this could be creating a histogram or a scatterplot. Mapping is a key visualization technique in spatial statistics. Modeling is a process that further extracts information from the data, typically by looking at relationships between multiple variables. All of the tasks mentioned above, and many more, can be handled easily in a variety of software applications. For this course, you will use the statistical computing language R. Figure 1.1: The process of doing data analysis (from Wickham and Grolemund, 2016) 1.2 Learning Objectives In this reading, you will learn: How to install R. About the RStudio Interactive Development Environment. About packages in R. 1.3 R: The Open Statistical Computing Project 1.3.1 What is R? R is an open-source language for statistical computing. It was created by Ross Ihaka and Robert Gentleman at the University of Auckland, in New Zealand, as a way to offer their students an accessible, no-cost tool for their courses. R is now maintained by the R Development Core Team, and developed by hundreds of contributors around the globe. R is an attractive alternative to other software applications for data analysis (e.g., Microsoft Excel, STATA) due to its open-source character (i.e., it is free), its flexibility, and large and dedicated user community, which means if there’s something you want to do (for instance, linear regression), it is very likely that someone has already developed functionality for it in R. A good way to think about R is as a core package, to which a library, consisting of additional packages, can be attached to increase its functionality. R can be downloaded for free at: https://cran.rstudio.com/ R comes with a built-in console (a user graphical interface), but better alternatives to the basic interface exist, including RStudio, an Integrated Development Environment, or IDE for short. RStudio can also be downloaded for free, by visiting the website: https://www.rstudio.com/products/rstudio/download/ R requires you to work using the command line, which is going to be unfamiliar to many of you accustomed to user-friendly graphical interfaces. Do not fear. People worked for a long time using the command line, or even more cumbersome, punched cards in early computers. Graphical user interfaces are convenient, but they have a major drawback, namely their inflexibility. A program that functions based on graphical user interfaces allows you to do only what is hard-coded in the user interface. Command line, as we will see, is somewhat more involved, but provides much more flexibility in operation. Go ahead. Install R and RStudio in your computer. (If you are at McMaster working in the GIS lab, you will find that these have already been installed there). Before introducing some basic functionality in R, lets quickly take a tour R Studio. 1.3.2 The RStudio IDE The RStudio IDE provides a complete interface to interact with the language R. It consists of a window with several panes. Some panes include in addition several tabs. There are the usual drop-down menus for common operations, such as creating new files, saving, common commands for editing, etc. See Figure 1.2 below. Figure 1.2: The RStudio IDE The editor pane allows you to open and work with text and other files, where you can write instructions that can be passed on to the program. Writing something in the editor does not execute any instructions, it merely records them for possible future use. In fact, much of what is written in the editor will not be instructions, but rather comments, discussion, and other text that is useful to understand code. The console pane is where instructions are passed on to the program. When an instruction is typed (or copied and pasted) there, R will understand that it needs to do something. The instructions must be written in a way that R understands, otherwise errors will occur. If you have typed instructions in the editor, you can use “ctrl-Enter” (in Windows) or “cmd-Enter” (in Mac) to send to the console and execute. The environment is where all data that is currently in memory is reported. The History tab acts like a log: it keeps track of the instructions that have been executed in the console. The last pane includes a number of useful tabs. The File tab allows you to navigate your computer, change the working directory, see what files are where, and so on. The Plot tab is where plots are rendered, when instructions require R to do so. The Packages tab allows you to manage packages, which as mentioned above, are pieces of code that can augment the functionality of R. The Help tab is where you can consult the documentation for functions/packages/see examples, and so on. The Viewer tab is for displaying local web content, for instance, to preview a Notebook (more on Notebooks soon). This brief introduction should have allowed you to install both R and RStudio. The next thing that you will need is packages. 1.4 Packages in R According to Wickham (2015) packages are the basic units of reproducible code in the R multiverse. Packages allow a developer to create a self-contained unit of code that often is meant to achieve some task. For instance, there are packages in R that specialize in statistical techniques, such as cluster analysis, visualization, or data manipulation. Some packages can be miscellaneous tools, or contain mostly datasets. Packages are a very convenient way of maintaining code, data, and documentation, and also of sharing all these resources. Packages can be obtained from different sources (including making them!). One of the reasons why R has become so successful is the relative facility with which packages can be distributed. A package that I use frequently is called tidyverse (Wickham 2017). The tidyverse is a collection of functions for data manipulation, analysis, and visualization. This package can be downloaded and installed in your personal library of R packages by using the function install.packages, as follows: install.packages(&quot;tidyverse&quot;) The function install.packages retrieves packages from the Comprehensive R Archive Network, or CRAN for short. CRAN is a collection of sites (accessible via the internet) that carry identical materials for distribution for R. There are other ways of distributing packages. For instance, throughout this book you will make use of a package called geog4ga3 that contains a collection of datasets and functions used in the readings or activities. This package is not on CRAN, but instead can be obtained from GitHub, a repository and versioning system. To retrieve packages from GitHub you need a function called install_github, which in turn is part of the package devtools. To download and install the package geog4ga3, you need first to download and install devtools as follows: install.packages(&quot;devtools&quot;) Once that a package has been downloaded and installed, it needs to be loaded into a session to be available to use. This allows you to have many packages in your library, but only a few of them loaded in a specific session when you need them. To load a package, you use the function library, as for example: library(devtools) And now, you can download and install the companion package for the book by doing the following: install_github(&quot;paezha/Spatial-Statistics-Course&quot;, subdir=&quot;geog4ga3&quot;) References "],
["basic-operations-and-data-structures-in-r.html", "Chapter 2 Basic Operations and Data Structures in R 2.1 Learning Objectives 2.2 RStudio IDE 2.3 Some Basic Operations 2.4 Data Classes in R 2.5 Data Types in R 2.6 Indexing and Data Transformations 2.7 Visualization 2.8 Creating a Simple Map", " Chapter 2 Basic Operations and Data Structures in R NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. Now that you have installed R and RStudio we can begin with an overview of basic operations and data structures in this computing language. Please note that this document you are reading, called an R Notebook, is an example of what is called “literate programming”, a style of document that uses code to illustrate a discussion, as opposed to the traditional programming style that uses natural language to discuss/document the code. It flips around the usual technical writing approach to make it more intuitive and accessible. Whenever you see a chunk of code as follows, you can run it (by clicking the ‘play’ icon on the top right corner) to see the results. Try it! print(&quot;Hello, Geography 4GA3&quot;) ## [1] &quot;Hello, Geography 4GA3&quot; The chunk of code above instructed R (and trough R the computer) to print (or display on the screen) some text. 2.1 Learning Objectives In this practice, you will learn: Basic operations in R. Data classes, data types, and data transformations. More about the use of packages in R. Basic visualization. 2.2 RStudio IDE If you are reading this, you probably already read the introductory chapter that instructed you to install R and RStudio. We can now proceed to discuss some basic concepts of operations and data types. 2.3 Some Basic Operations R can perform many types of operations. Some simple operations are arithmetic. Other are logical. And so on. For instance, R can be instructed to conduct sums, as follows: 2 + 2 ## [1] 4 R can be instructed to do multiplications: 2 * 3 ## [1] 6 And sequences of operations, using brackets to indicate their order. Compare the following two expressions: 2 * 3 + 5 ## [1] 11 2 * (3 + 5) ## [1] 16 Other operations produce logical results (values of true and false): 3 &gt; 2 ## [1] TRUE 3 &lt; 2 ## [1] FALSE And of course, you can combine operations in an expression: 2 * 3 + 5 &lt; 2 * (3 + 5) ## [1] TRUE As you can see, R can be used as a calculator, but it is much more powerful than that. We can also create variables. You can think of a variable as a box with a name, whose contents can change. Variables are used to keep track of important stuff in your calculations, and to automate operations. To create a variable, a value is assigned to a name, using this notation &lt;-. You can read this x &lt;- 2 as “assign value of 2 to a variable called x”. For instance: x &lt;- 2 y &lt;- 3 z &lt;- 5 Check your “Global Environment”, the tab where the contents of your “Workspace” are displayed for you. You can also simply type the name of the variable in the Console to see its contents. Now that we have some variables with values, we can express operations as follows (same as above) x * y + z ## [1] 11 x * (y + z) ## [1] 16 However, if we wanted, we could change the values of any of x, y, and/or z and repeat the operations. This allows to automate some instructions: x &lt;- 4 x * y + z ## [1] 17 2.4 Data Classes in R R can work with different data classes, including: Numerical Character Logical Factor This allows you to store information in different forms, which can be useful. For instance, you may want to save some text: name &lt;- &quot;Hamilton&quot; Or numerical information: population &lt;- 551751 If you wish to check what class an object is, you can use the function class: class(name) ## [1] &quot;character&quot; class(population) ## [1] &quot;numeric&quot; 2.5 Data Types in R R can work with different data types, including scalars (essentially matrices with only one element), vectors (matrices with one dimension of size 1) and matrices (more generally. print(&#39;This is a scalar&#39;) ## [1] &quot;This is a scalar&quot; 1 ## [1] 1 print(&#39;This is a vector&#39;) ## [1] &quot;This is a vector&quot; c(1,2,3,4) ## [1] 1 2 3 4 print(&#39;This is a matrix&#39;) ## [1] &quot;This is a matrix&quot; matrix(c(1,2,3,4),nrow = 2, ncol=2) ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 The command c() is used to concatenate the arguments. The command matrix() creates a matrix with the specified number of rows and columns. An important data type in R is a data frame. A data frame is a table consisting of rows and columns - commonly a set of vectors that have been collected for convenience. A data frame is used to store data in digital format. (If you have used Excel or another spreadsheet software before, data frames will be familiar to you: they look a lot like a sheet in a spreadsheet.) A data frame can accommodate large amounts of information (several billion individual items). The data can be numeric, character, logical, and so on. Each grid cell in a data frame has an address that can be identified based on the row and column it belongs to. R can use these addresses to perform mathematical operations. R labels columns alphabetically and rows numerically (or less commonly alphabetically). To illustrate a data frame, let us first create the following vectors, that include names, populations, average salaries, and coordinates of some cities: Name &lt;- c(&#39;Hamilton&#39;,&#39;Waterloo&#39;,&#39;Toronto&#39;) Population &lt;- c(551751, 219153, 2731571) AvgSalary &lt;- c(45692, 57625, 48920) Latitude &lt;- c(43.255203, 43.4668, 43.6532) Longitude &lt;- c(-79.843826, -80.51639, -79.3832) Again, note that &lt;- is an assignment. In other words, it assigns the item on the right to the name on the left. After you execute the chunk of code above, you will notice that new values appear in your Environment. These are five vectors of size 1:3, one that is composed of alphanumeric information (or chr, for ‘character’) and four columns that are numeric (num). These vectors can be collected in a dataframe. This is done for convenience, so we know that all these data belong together in some way. Please note that to create a data frame, the vectors must have the same length. In other words, you cannot create a table with elements that have different numbers of rows (other data types allow you to do this, but not data frames). We will now create a data frame. We will call it “Cities”. There are rules for names, but in most cases it helps if the names are intuitive and easy to remember. The function used to create a data frame is data.frame() and the arguments are the vectors that we wish to collect there. Cities &lt;- data.frame(Name, Population, AvgSalary, Latitude, Longitude) After running the chunk above, now you have a new object in your environment, namely a data frame called Cities. If you double clic on Cities in the Environment tab, you will see that this data frame has five columns (labeled Name, Population, AvgSalary, Latitude, and Longitude), and three rows. You can enter data into a data frame and then use the many built-in functions of R to perform various types of analysis. Please note that Name, which was an alphanumeric vector, was converted to a factor in the data frame. A factor is a way to store nominal variables that may have two or more levels. In the present case, the factor variable has three levels, corresponding to three cities. If we had information for multiple years, each city might appear more than once, for each year that information was available. 2.6 Indexing and Data Transformations Data frames store information that is related in a compact way. To perform operations effectively, it is useful to understand the way R locates information in a data frame. As noted before, each grid cell has an address, or in other words an index, that can be referenced in several convenient ways. For instance, assume that you wish to reference the first value of the data frame, in other words, row 1 of column Name. To do this, you would go use the following instruction: Cities[1,1] ## [1] Hamilton ## Levels: Hamilton Toronto Waterloo This will recall the element in the first row and first column of Cities. As an alternative, you could type: Cities$Name[1] ## [1] Hamilton ## Levels: Hamilton Toronto Waterloo As you see, this has the same effect. The string sign $ is used to reference columns in a data frame. Therefore, R will call the first element of Name in data frame Cities. Cities[1,2] is identical to Cities$Name[2]. Try changing the code in the chunk and executing. If you type Cities$Name, R will recall the full column. Indexing is useful to conduct operations. Suppose for instance, that you wished to calculate the total population of two cities, say Hamilton and Waterloo. You can execute the following instructions: Cities$Population[1] + Cities$Population[2] ## [1] 770904 (More involved indexing is also possible, for example, if we use logical operators. Do not worry too much about the details, but you can verify that the results are identical) Cities$Population[Cities$Name==&#39;Hamilton&#39;] + Cities$Population[Cities$Name==&#39;Waterloo&#39;] ## [1] 770904 Suppose that you wanted to calculate the total population of the cities in your data frame. To do this, you would use the instruction sum: sum(Cities$Population) ## [1] 3502475 You have already seen how it allows you to store in memory the results of some instruction, by means of an assignment &lt;-. You can also perform many other useful operations. For instance, calculate the maximum value for a set of values: max(Cities$Population) ## [1] 2731571 And, if you wanted to find which city is the one with the largest population, you would use a logical statement as an index: Cities$Name[Cities$Population==max(Cities$Population)] ## [1] Toronto ## Levels: Hamilton Toronto Waterloo As you see, Toronto is the largest city (by population) in this dataset. Using indexing in imaginative ways provides a way to do fairly sophisticated data analysis. Likewise, the function for finding the minimum value for a set of values is min: min(Cities$Population) ## [1] 219153 Try calculating the average of the population of the cities, using the command mean. Use the empty chunk below for this (the result should be 1167492): Finding the maximum and minimum, aggregating (calculating the sum of a series of values), and finding the average are examples of transformations applied to the data. They give insights into aspects of the dataset that are not evident from the raw data. 2.7 Visualization The data frame, in essence a table, informative as it is, may not be the best way to learn from the data. Visualization is often a valuable complement to data analysis. Say, we might be interested in finding which city has the largest population and which city has the smallest population. We could achieve this by using similar instructions as before, for example: paste(&#39;The city with the largest population is&#39;,Cities$Name[Cities$Population==max(Cities$Population)]) ## [1] &quot;The city with the largest population is Toronto&quot; paste(&#39;The city with the smallest population is&#39;, Cities$Name[Cities$Population==min(Cities$Population)]) ## [1] &quot;The city with the smallest population is Waterloo&quot; (Note that paste is similar to print, except that it converts everything to characters before printing. We use this command because the contents of Name in data frame Cities are not characters, but levels.) A more convenient way of understanding these data is by visualizing them, using for instance a bar chart. We will proceed to create a bar chart, using a package called ggplot2. This package implements a grammar of graphics, and is a very flexible way of creating plots in R. Since ggplot2 is a package, we first must ensure that it is installed. You can install it using the command install as follows: install.packages(&quot;ggplot2&quot;) As an alternative, you can use the Packages tab in RStudio. Simply navigate to the tab, click install, and select ggplot2 from there. Note that you need to install the package only once! Essentially install adds it to your library of packages, where it will remain available. Once the package is installed, it becomes available, but to use it you must load it in memory. For this, we use the command library(), which is used to load a package, that is, to activate it for use. Assuming that you already have installed ggplot2, we proceed to load it: library(ggplot2) Now all commands from the ggplot2 package are available to you. This package works by layering a series of objects, beginning with a blank plot, to which we can add things. The command to create a plot is ggplot(). This command accepts different arguments. For instance, we can pass data to it in the form of a data frame. We can also indicate different aesthetic values, that is, the things that we wish to plot. None of this is plotted, though, until we indicate which kind of geom or geometric object we wish to plot. For a bar chart, we would use the following instructions: ggplot(data = Cities, aes(x = Name, y = Population)) + geom_bar(stat = &#39;identity&#39;) Let us break down these instructions. We are asking ggplot2 to create a plot that will use the data frame Cities. Furthermore, we tell it to use the values of Names in the x-axis, and the values of Population in the y-axis. Run the following chunk: ggplot(data = Cities, aes(x = Name, y = Population)) Notice how ggplot2 creates a blank plot, but it has yet to actually render any of the population information in there. We layer elements on a plot by using the + sign. It is only when we tell the package to add some geometric element that it renders something on the plot. In the previous case, we told ggplot2 to draw bars (by using the geom_bar command). The argument of geom_bar was stat = 'identity', to indicate that the data for the y-axis was to be used ‘as-is’ without further statistical transformations. There are many different geoms that can be used in ggplot2. You can always consult the help/tutorial files by typing ??ggplot2 in the console. See: ??ggplot2 ## starting httpd help server ... done 2.8 Creating a Simple Map We will see how maps are used in spatial statistical analysis. The simplest one that can be created is a so-called dot map that displays the location of an event of interest. A dot map is, in fact, simply a scatterplot of the coordinates of events. We can use ggplot2 to create a simple dot map of the cities in your simple dataset. For this, we create a ggplot object, and for the x and y aesthetics we use the coordinates. The geometric element that we want to render is a point: ggplot(data = Cities, aes(x = Longitude, y = Latitude)) + geom_point() This is a simple dot map that simply shows the locations of the cities. We can add labels by means of the geometric element text: ggplot(data = Cities, aes(x = Longitude, y = Latitude)) + geom_point() + geom_text(aes(label = Name)) A proportional symbol map changes the size of the symbols to add information to the plot. To create a proportional symbol map, we add to the aesthetics the instruction to use some variable for the size of the symbols: ggplot(data = Cities, aes(x = Longitude, y = Latitude)) + geom_point(aes(size = Population)) + geom_text(aes(label = Name)) And fix the position of the labels by adding a vertical justification to the text (vjust) and expanding the limits of the plot (expand_limits): ggplot(data = Cities, aes(x = Longitude, y = Latitude)) + geom_point(aes(size = Population)) + geom_text(aes(label = Name), vjust = 2) + expand_limits(x = c(-80.7, -79.2), y = c(43.2, 43.7)) You have now created a relatively simple proportional symbols map! You can see that creating a plot is simply a matter of instructing R (through ggplot2) to complete a series of instructions: Create a ggplot2 object using a dataset, which will render stuff at locations given by variable1 and variable 2: ggplot(data = dataset, aes(x = variable1, y = variable2)) Add stuff to the plot. For instance, to add points use geom_point, to add lines use geom_line, and so on. Check the ggplot2 Cheat Sheet for more information on how to use this package. A last note. Many other visualization alternatives (for instance, Excel) provide point-and-click functions for creating plots. In contrast, ggplot2 in R requires that the plot be created by meticulously instructing the package what to do. While this is more laborious, it also means that you have complete control over the creation of plots, which in turn allows you to create more flexible and inventive visuals. This concludes your basic overview of basic operations and data structures in R. You will have an opportunity to learn more about creating maps in R with your reading. "],
["introduction-to-mapping-in-r.html", "Chapter 3 Introduction to Mapping in R 3.1 Learning Objectives 3.2 Suggested Readings 3.3 Preliminaries 3.4 Packages 3.5 Exploring Dataframes and a Simple Proportional Symbols Map 3.6 Improving on the Proportional Symbols Map 3.7 Some Simple Spatial Analysis 3.8 Other Resources", " Chapter 3 Introduction to Mapping in R NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. Spatial statistics is a sub-field of spatial analysis that has grown in relevance in recent years as a result of 1) the availability of information that is geo-coded, in other words, that has geographical references; and 2) the availability of software to analyze such information. A key technology fuelling this trend is that of Geographical Information Systems (GIS). GIS are, at their simplest, digital mapping for the 21st century. In most cases, however, GIS go beyond cartographic functions to also enable and enhance our ability to analyze data. There are many available packages for geographical information analysis. Some are very user friendly, and widely available in many institutional contexts, such as ESRI’s Arc software. Others are fairly specialized, such as Caliper’s TransCAD, which implements many operations of interest for transportation engineering and planning. Others packages have the advantage of being more flexible and/or free. Such is the case of the R statistial computing language. R has been adopted by many in the spatial analysis community, and a number of specialized libraries have been developed to support mapping and spatial data analysis functions. The objective of this note is to provide an introduction to mapping in R. Maps are one of the fundamental tools of spatial statistics and spatial analysis, and R allows for many GIS-like functions. If you wish to work interactively with this chapter you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. In the previous reading/practice you created a simple proportional symbols map. In this reading/practice you will learn how to create more sophisticated maps in R. 3.1 Learning Objectives In this reading, you will: Revisit how to install and load a package. Learn how to invoke a data and view the data structure. Learn how to easily create maps using R. Think about how statistical maps help us understand patterns. 3.2 Suggested Readings Bivand RS, Pebesma E, Gomez-Rubio V (2008) Applied Spatial Data Analysis with R, Chapters 2-3. Springer: New York Brunsdon C and Comber L (2015) An Introduction to R for Spatial Analysis and Mapping, Chapter 3. Sage: Los Angeles 3.3 Preliminaries It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. 3.4 Packages According to Wickham (2015) packages are the basic units of reproducible code in the R multiverse. Now that your workspace is clear, you can proceed to load a package. In this case, the package is the one used for this book/course, called geog4ga3. The function used to load a package is library, as follows: library(geog4ga3) The package includes a few datasets that will be used throughout the book. You can check which datasets are available in this package by using the function data: data(&quot;snow_deaths&quot;) 3.5 Exploring Dataframes and a Simple Proportional Symbols Map If you correctly loaded the library, you can now access the dataframes in the package geog4ga3. For this section, you will need two dataframes, namely snow_pumps and snow_deaths. You can examine the contents of these dataframes by means of the command head. This command displays the first few rows of the dataframe. Try it: head(snow_deaths) ## long lat Id Count ## 0 -0.1379301 51.51342 1 3 ## 1 -0.1378831 51.51336 2 2 ## 2 -0.1378529 51.51332 3 1 ## 3 -0.1378120 51.51326 4 1 ## 4 -0.1377668 51.51320 5 4 ## 5 -0.1375369 51.51318 6 2 These data are from the famous London cholera example. This is the study by John Snow (not the one from Game of Thrones, but the British physician) into the cholera outbreak of Soho, London, in 1854. John Snow is considered the father of spatial epidemiology, and his study mapping the outbreak is credited with helping find its cause. The dataframe snow_deaths includes the geocoded addresses of cholera deaths in long and lat, and the number of deaths (the Count) recorded at each address, as well as unique identifiers for the addresses (Id). A second dataframe snow_pumps includes the geocoded locations of water pumps in Soho: head(snow_pumps) ## long lat Id Count ## 01 -0.1366679 51.51334 251 1 ## 1100 -0.1395862 51.51388 252 1 ## 250 -0.1396710 51.51491 253 1 ## 310 -0.1316299 51.51235 254 1 ## 410 -0.1335944 51.51214 255 1 ## 510 -0.1359191 51.51154 256 1 As in your previous reading, it is possible to map the cases using ggplot2. Begin by loading the package you will need: library(tidyverse) ## -- Attaching packages -------------------------------------------------------------------------------- tidyverse 1.2.1 -- ## v ggplot2 3.1.0 v purrr 0.2.5 ## v tibble 2.0.1 v dplyr 0.7.8 ## v tidyr 0.8.2 v stringr 1.3.1 ## v readr 1.3.1 v forcats 0.3.0 ## -- Conflicts ----------------------------------------------------------------------------------- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Now, you can create a blank ggplot2 object on which you can render the points for deaths and the pumps. ggplot() + geom_point(data = snow_deaths, aes(x = long, y = lat), color = &quot;blue&quot;, shape = 16) + geom_point(data = snow_pumps, aes(x = long, y = lat), color = &quot;black&quot;, shape = 17) This does a decent job of displaying the information, now using different colors and shapes for different types of events (deaths and pumps). However, it is not a very good quality map. 3.6 Improving on the Proportional Symbols Map A package that extends the functionality of mapping in R is leaflet. We will see next how to enhance our proportional symbol map using this package. First you need to load the package (you need to install it first if you have not already): library(leaflet) The first step is to create a leaflet object, which will be saved in m. To do this we use the function leaflet and we indicate a dataset to use for our map, in this case the dataframe snow_deaths. In addition, we set the view for the map using the setView function, and indicate the center of the map (which we can get after inspecting the previous symbols map), as well as the zoom (16 is the zoom for a neighborhood): m &lt;- leaflet(data = snow_deaths) %&gt;% setView(lng = -0.136, lat = 51.513, zoom = 16) We can add a basemap or background map by means of the addTiles function: m &lt;- m %&gt;% addTiles() Finally, we add the cases of cholera deaths to the map. For this, we indicate the coordinates (preceded by ~), and set an option for clustering by means of the clusterOptions as follows: m &lt;- m %&gt;% addMarkers(~long, ~lat, clusterOptions = markerClusterOptions(), group = &quot;Deaths&quot;) m To the map above we could also add the location of the pumps (notice that the Broad Street Pump is already shown in the basemap!): m %&gt;% addMarkers(data = snow_pumps, ~long, ~lat, group = &quot;Pumps&quot;) The above results in a much nicer map. Is this map informative? What does it tell you about the incidence of cholera and the location of the pumps? 3.7 Some Simple Spatial Analysis We could even begin to do some spatial analysis on this map! For instance, we could create a heatmap. You have probably seen heatmaps in many different situations before, as they are a popular visualization tool. Heatmaps are created based on a spatial analytical technique called kernel analysis. We will cover this technique in more detail later on. For the time being, it can be illustrated by taking advantage of the leaflet.extras package, which contains a heatmap function. Load the package as follows: library(leaflet.extras) Next, create a second leaflet object for this example, and call it m2. Notice that we are using the same setView parameters: m2 &lt;- leaflet(data = snow_deaths) %&gt;% setView(lng = -0.136, lat = 51.513, zoom = 16) %&gt;% addTiles() Then, add the heatmap. The function used to do this is addHeatmap. We specify the coordinates and the variable for the intensity (i.e., each case in the dataframe is representative of Count deaths at the address). Two parameters are important here, the blur and the radius. If you are working with the R notebook version of the book, experiment changing these parameters: m2 %&gt;% addHeatmap(lng = ~long, lat = ~lat, intensity = ~Count, blur = 40, max = 1, radius = 25) Lastly, you can also add markers for the pumps as follows: m2 %&gt;% addHeatmap(lng = ~long, lat = ~lat, intensity = ~Count, blur = 40, max = 1, radius = 25) %&gt;% addMarkers(data = snow_pumps, ~long, ~lat, group = &quot;Pumps&quot;) A heatmap (essentially a kernel density of spatial points; more on this in a later chapter) makes it very clear that most cases of cholera happend in the neighborhood of one (possibly contaminated) water pump! At the time, Snow noted with respect to this geographical pattern that: “It will be observed that the deaths either very much diminished, or ceased altogether, at every point where it becomes decidedly nearer to send to another pump than to the one in Broad street. It may also be noticed that the deaths are most numerous near to the pump where the water could be more readily obtained.” Snow’s analysis led to the closure of the pump, after which the cholera outbreak subsided. This illustrates how even some relatively simple spatial analysis can help to inform public policy and even save lives. You can read more about this case here. In this practice you have learned how to implement some simple mapping and spatial statistical analysis using R. In future readings we will further explore the potential of R for both. 3.8 Other Resources If you would like to experiment some more with this dataset, visit a Shiny app that lets you explore this dataset. For more information on the functionality of leaflet, please check Leaflet for R References "],
["activity-1-statistical-maps-i.html", "Chapter 4 Activity 1: Statistical Maps I 4.1 Housekeeping Questions 4.2 Learning Objectives 4.3 Preliminaries 4.4 Creating a simple thematic map 4.5 Activity", " Chapter 4 Activity 1: Statistical Maps I Remember, you can download the source file for this activity from here. 4.1 Housekeeping Questions Answer the following questions: What are the office hours of your instructor this term? How are assignments graded? What is the policy for late assignments in this course? 4.2 Learning Objectives In this activity you will: Discuss statistical maps and what makes them interesting. 4.3 Preliminaries In the practice that preceded this activity, you used ggmap to create a proportional symbol map, a mapping technique used in spatial statistics for visualization of geocoded event information. As well, you implemented a simple technique called kernel analysis to the map to explore the distribution of events in the case of the cholera outbreak of Soho in London in 1854. Geocoded events are often called point patterns, so with the cholera data you were working with a point pattern. In this activity, we will map another type of spatial data, called areal data. Areas are often administrative or political jurisdictions. For this activity you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) library(sf) library(geog4ga3) 4.4 Creating a simple thematic map If you successfully loaded package geog4ga3 a dataset called HamiltonDAs should be available for analysis: data(HamiltonDAs) Check the class of this object: class(HamiltonDAs) ## [1] &quot;sf&quot; &quot;data.frame&quot; As you can see, this is an object of class sf, which stands for simple features. Objects of this class are used in the R package sf (see here) to implement standards for spatial objects. You can examine the contents of the dataset by means of head (which will show the top rows): head(HamiltonDAs) ## Simple feature collection with 6 features and 7 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 563306.2 ymin: 4777681 xmax: 610844.5 ymax: 4793682 ## epsg (SRID): 26917 ## proj4string: +proj=utm +zone=17 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ## ID GTA06 VAR1 VAR2 VAR3 VAR4 VAR5 ## 1 2671 5030 0.74650172 0.2596975 0.6361925 0.2290084 0.7223464 ## 2 2716 5077 0.78107142 0.4413119 0.5690740 0.8997258 0.4163702 ## 3 2710 5071 0.78824936 0.4632757 0.4197216 0.1619401 0.3052948 ## 4 2745 5108 0.82064933 0.6365193 0.9504535 0.4992477 0.6046399 ## 5 2810 5177 0.09131849 0.4455965 0.3539603 0.4919869 0.6366968 ## 6 2740 5103 0.22257665 0.6288826 0.1341962 0.6635202 0.4429712 ## geometry ## 1 MULTIPOLYGON (((605123.4 47... ## 2 MULTIPOLYGON (((606814 4784... ## 3 MULTIPOLYGON (((605293 4785... ## 4 MULTIPOLYGON (((607542.7 47... ## 5 MULTIPOLYGON (((564681.8 47... ## 6 MULTIPOLYGON (((574373.4 47... Or obtain the summary statistics by means of summary: summary(HamiltonDAs) ## ID GTA06 VAR1 VAR2 ## 2299 : 1 4050 : 1 Min. :0.0000 Min. :0.0000 ## 2300 : 1 4051 : 1 1st Qu.:0.3680 1st Qu.:0.3800 ## 2301 : 1 4052 : 1 Median :0.5345 Median :0.4937 ## 2302 : 1 4053 : 1 Mean :0.5241 Mean :0.4966 ## 2303 : 1 4054 : 1 3rd Qu.:0.6938 3rd Qu.:0.6091 ## 2304 : 1 4055 : 1 Max. :1.0000 Max. :1.0000 ## (Other):291 (Other):291 ## VAR3 VAR4 VAR5 geometry ## Min. :0.0000 Min. :0.0000 Min. :0.0000 MULTIPOLYGON :297 ## 1st Qu.:0.3521 1st Qu.:0.2989 1st Qu.:0.2998 epsg:26917 : 0 ## Median :0.5699 Median :0.5476 Median :0.4810 +proj=utm ...: 0 ## Mean :0.5548 Mean :0.5325 Mean :0.5001 ## 3rd Qu.:0.7378 3rd Qu.:0.7894 3rd Qu.:0.6915 ## Max. :1.0000 Max. :1.0000 Max. :1.0000 ## The above will include a column for the geometry of the spatial features. The dataframe includes all Dissemination Areas (or DAs for short) for the Hamilton Census Metropolitan Arean in Canada. DAs are a type of geography used by the Census of Canada, in fact the smallest geography that is publicly available. To create a siple map we can use ggplot2, which previously we used to map points. Now, the geom for objects of class sf can be used to plot areas. To create such a map, we layer a geom object of type sf on a ggplot2 object. For instance, to plot the DAs: #head(HamiltonDAs) ggplot(HamiltonDAs) + geom_sf(fill = &quot;gray&quot;, color = &quot;black&quot;, alpha = .3, size = .3) We selected color “black” for the polygons, with a transparency alpha = 0.3 (alpha = 0 is completely transparent, alpha = 1 is completely opaque, try it!), and line size 0.3. This map only shows the DAs, which is nice. However, as you saw in the summary of the dataframe above, in addition to the geometric information, a set of (generic) variables is also included, called VAR1, VAR2,…, VAR5. Thematic maps can be created using these variables. The next chunk of code plots the DAs and adds info. The fill argument is used to select a variable to color the polygons. The function cut_number is used to classify the values of the variable in \\(k\\) groups of equal size, in this case 5 (notice that the lines of the polygons are still black). The scale_fill_brewer function can be used to select different palettes or coloring schemes): ggplot(HamiltonDAs) + geom_sf(aes(fill = cut_number(HamiltonDAs$VAR1, 5)), color = &quot;black&quot;, alpha = 1, size = .3) + scale_fill_brewer(palette = &quot;Reds&quot;) + coord_sf() + labs(fill = &quot;Variable&quot;) Now you have seen how to create a thematic map with polygons (areal data), you are ready for the following activity. 4.5 Activity Create thematic maps for variables VAR1 through VAR5 in the dataframe HamiltonDAs. Remember that you can introduce new chunks of code. Imagine that these maps were found, and for some reason the variables were not labeled. They may represent income, or population density, or something else. Which of the five maps you just created is more interesting? Rank the five maps from most to least interesting. Explain the reasons for your ranking. "],
["mapping-in-r-continued.html", "Chapter 5 Mapping in R: Continued 5.1 Learning Objectives 5.2 Suggested Readings 5.3 Preliminaries 5.4 Summarizing a Dataframe 5.5 Factors 5.6 Subsetting Data 5.7 Pipe Operator 5.8 More on Visualization 5.9 Other Resources", " Chapter 5 Mapping in R: Continued NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. In the preceding chapters, you were introduced to the following concepts: Basic operations in R. These include arithmetic and logical operations, among others. Data classes in R. Data can be numeric, characters, logical values, etc. Data types in R. Ways to store data, for instance as vector, matrix, dataframes, etc. Indexing. Ways to retrieve information from a data frame by referring to its location therein. Creating simple maps in R. Please review the previous practices if you need a refresher on these concepts. If you wish to work interactively with this chapter you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. 5.1 Learning Objectives In this reading, you will learn: How to quickly summarize the descriptive statistics of a dataframe. More about factors. Factors are a class of data that is used for categorical data. For instance, a parcel may be categorizes as developed or undeveloped; a plot of land may be zoned for commercial, residential, or industrial use; a sample may be mineral x or y. These are not quantities but rather reflect a quality of the entity that is being described. How to subset a dataset. Sometimes you want to work with only a subset of a dataset. This can be done using indexing with logical values, or using specialized functions. How to use pipe operators. A pipe operator allows you to pass the results of a function to another function. It makes writing instructions more intuitive and simple. You have already seen pipe operators earlier: they look like this %&gt;%. You will add layers to a ggplot object to improve a map. 5.2 Suggested Readings Bivand RS, Pebesma E, Gomez-Rubio V (2008) Applied Spatial Data Analysis with R, Chapters 2-3. Springer: New York. Brunsdon C and Comber L (2015) An Introduction to R for Spatial Analysis and Mapping, Chapter 3. Sage: Los Angeles. O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapters 1-3. John Wiley &amp; Sons: New Jersey. 5.3 Preliminaries As usual, it is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) library(geog4ga3) Now that your workspace is clear, you can proceed to invoke the sample dataset. You can do this by means of the function data. data(&quot;missing_df&quot;) The dataframe missing_df includes \\(n = 65\\) observations (Note: text between $ characters is mathematical notation in LaTeX). These observations are geocoded using a false origin and coordinates normalized to the unit-square (the extent of their values is between zero and one). The coordinates are x and y. In addition, there are three variables associated with the locations (VAR1, VAR2, VAR3). The variables are generic. Feel free to think of them as if they were housing prices or concentrations in ppb of some contaminant. Finally, a factor variable states whether the variables were measured for a location: if the status is “FALSE”, the values of the variables are missing. 5.4 Summarizing a Dataframe Obtaining the a set of descriptive statistics for a dataframe is very simple thanks to the function summary. For instance, the summary of missing_df is: summary(missing_df) ## x y VAR1 VAR2 ## Min. :0.01699 Min. :0.01004 Min. : 50.0 Min. : 50.0 ## 1st Qu.:0.22899 1st Qu.:0.19650 1st Qu.: 453.3 1st Qu.: 570.1 ## Median :0.41808 Median :0.50822 Median : 459.1 Median : 574.4 ## Mean :0.49295 Mean :0.46645 Mean : 458.8 Mean : 562.1 ## 3rd Qu.:0.78580 3rd Qu.:0.74981 3rd Qu.: 465.4 3rd Qu.: 594.2 ## Max. :0.95719 Max. :0.98715 Max. :1050.0 Max. :1050.0 ## NA&#39;s :5 NA&#39;s :5 ## VAR3 Observed ## Min. : 50.0 FALSE: 5 ## 1st Qu.: 630.3 TRUE :60 ## Median : 640.0 ## Mean : 638.1 ## 3rd Qu.: 646.0 ## Max. :1050.0 ## NA&#39;s :5 This function reports the minimum, maximum, mean, median, and quantile values of a numeric variable. When variables are characters or factors, their frequency is reported. For instance, in missing_df, there are five instances of FALSE and sixty instances of TRUE. 5.5 Factors A factor describes a category. You can examine the class of a variable by means of the function class. From the summary, it is clear that several variables are numeric. However, for Observed, it is not evident if the variable is character or factor. Use of class reveals that it is indeed a factor: class(missing_df$Observed) ## [1] &quot;factor&quot; Factors are an important data type because they allow us to store information that is not measured as a quantity. For example, the quality of the cut of a diamond is categorized as Fair &lt; Good &lt; Very Good &lt; Premium &lt; Ideal. Sure, we could store this information as numbers from 1 to 5. However, the quality of the cut is not a quantity, and should not be treated like one. In the dataframe missing_df, the variable Observed could have been coded as 1’s (for missing) and 2’s (for observed), but this does not mean that one observed is twice the amount of one missing! In this case, the numbers would not be quantities but labels. Factors in R allow us to work directly with the labels. Now, you may be wondering what does it mean when the status of a datum’s Observed variable is coded as FALSE. If you check again the summary, there are five cases of NA in the variables VAR1 through VAR3. NA essentially means that the value is missing. Likely, the five NA values correspond to the five missing observations. We can check this by subsetting the data. 5.6 Subsetting Data We subset data when we wish to work only with parts of a dataset. We can do this by indexing. For example, we could retrieve the part of the dataframe that corresponds to the FALSE values in the Observed variable: missing_df[missing_df$Observed == FALSE,] ## x y VAR1 VAR2 VAR3 Observed ## 61 0.34 0.83 NA NA NA FALSE ## 62 0.29 0.52 NA NA NA FALSE ## 63 0.13 0.32 NA NA NA FALSE ## 64 0.62 0.10 NA NA NA FALSE ## 65 0.88 0.85 NA NA NA FALSE Data are indexed by means of the square brackets [ and ]. The indices correspond to the rows and columns. The logical statement missing_df$Observed == False selects the rows that meet the condition, whereas leaving a blank for the columns simply means “all columns”. As you can see, the five NA values correspond, as anticipated, to the locations where Observed is FALSE. Using indices is only one of different ways of subsetting data. Base R also has a subset command, that is implemented as follows: subset(missing_df, Observed == FALSE) ## x y VAR1 VAR2 VAR3 Observed ## 61 0.34 0.83 NA NA NA FALSE ## 62 0.29 0.52 NA NA NA FALSE ## 63 0.13 0.32 NA NA NA FALSE ## 64 0.62 0.10 NA NA NA FALSE ## 65 0.88 0.85 NA NA NA FALSE And the package dplyr (part of the tidyverse) has a function called filter: filter(missing_df, Observed == FALSE) ## x y VAR1 VAR2 VAR3 Observed ## 1 0.34 0.83 NA NA NA FALSE ## 2 0.29 0.52 NA NA NA FALSE ## 3 0.13 0.32 NA NA NA FALSE ## 4 0.62 0.10 NA NA NA FALSE ## 5 0.88 0.85 NA NA NA FALSE The three approaches give the same result, but subset and filter are somewhat easier to write. You could nest any of the above approaches as part of another function. For instance, if you wanted to do a summary of the selected subset of the data, you would: summary(filter(missing_df, Observed == FALSE)) ## x y VAR1 VAR2 VAR3 ## Min. :0.130 Min. :0.100 Min. : NA Min. : NA Min. : NA ## 1st Qu.:0.290 1st Qu.:0.320 1st Qu.: NA 1st Qu.: NA 1st Qu.: NA ## Median :0.340 Median :0.520 Median : NA Median : NA Median : NA ## Mean :0.452 Mean :0.524 Mean :NaN Mean :NaN Mean :NaN ## 3rd Qu.:0.620 3rd Qu.:0.830 3rd Qu.: NA 3rd Qu.: NA 3rd Qu.: NA ## Max. :0.880 Max. :0.850 Max. : NA Max. : NA Max. : NA ## NA&#39;s :5 NA&#39;s :5 NA&#39;s :5 ## Observed ## FALSE:5 ## TRUE :0 ## ## ## ## ## Or: summary(missing_df[missing_df$Observed == FALSE,]) ## x y VAR1 VAR2 VAR3 ## Min. :0.130 Min. :0.100 Min. : NA Min. : NA Min. : NA ## 1st Qu.:0.290 1st Qu.:0.320 1st Qu.: NA 1st Qu.: NA 1st Qu.: NA ## Median :0.340 Median :0.520 Median : NA Median : NA Median : NA ## Mean :0.452 Mean :0.524 Mean :NaN Mean :NaN Mean :NaN ## 3rd Qu.:0.620 3rd Qu.:0.830 3rd Qu.: NA 3rd Qu.: NA 3rd Qu.: NA ## Max. :0.880 Max. :0.850 Max. : NA Max. : NA Max. : NA ## NA&#39;s :5 NA&#39;s :5 NA&#39;s :5 ## Observed ## FALSE:5 ## TRUE :0 ## ## ## ## ## Nesting functions makes it difficult to read the code, since functions are evaluated from the innermost to the outermost function, whereas we are used to read from left to right. Fortunately, R implements (as part of package magrittr which is required by tidyverse) a so-called pipe operator that simplifies things and allows for code that is more intuitive to read. 5.7 Pipe Operator A pipe operator is written this way: %&gt;%. Its objective is to pass forward the output of a function to a second function, so that they can be chained to create more complex instructions that are still relatively easy to read. For instance, instead of nesting the subsetting instructions in the summary function, you could do the subsetting first, and pass the results of that to the summary for further processing. This would look like this: subset(missing_df, Observed == FALSE) %&gt;% summary() ## x y VAR1 VAR2 VAR3 ## Min. :0.130 Min. :0.100 Min. : NA Min. : NA Min. : NA ## 1st Qu.:0.290 1st Qu.:0.320 1st Qu.: NA 1st Qu.: NA 1st Qu.: NA ## Median :0.340 Median :0.520 Median : NA Median : NA Median : NA ## Mean :0.452 Mean :0.524 Mean :NaN Mean :NaN Mean :NaN ## 3rd Qu.:0.620 3rd Qu.:0.830 3rd Qu.: NA 3rd Qu.: NA 3rd Qu.: NA ## Max. :0.880 Max. :0.850 Max. : NA Max. : NA Max. : NA ## NA&#39;s :5 NA&#39;s :5 NA&#39;s :5 ## Observed ## FALSE:5 ## TRUE :0 ## ## ## ## ## The code above is read as “subset missing_df and pass the results to summary”. Pipe operators make writting and reading code somewhat more natural. 5.8 More on Visualization Observations in the sample dataset are georeferenced, and so they can be plotted. Since they are based on false origins and are normalized, we cannot map them to the surface of the Earth. However, we can still visualize their spatial distribution. This can be done by using ggplot2. For instance, for missing_df: ggplot() + geom_point(data = missing_df, aes(x = x, y = y), shape = 17, size = 3) + coord_fixed() The above simply plots the coordinates, so that we can see the spatial distribution of the observations. (Notice the use of coord_fixed to maintain the aspect ratio of the plot to 1, the relationship between width and height). You have control of the shape of the markers, as well as their size. You can consult the shapes available here. Experiment with different shapes and sizes if you wish. The dataframe missing_df includes more attributes that could be used in the plot. For instance, if you wished to create a thematic map showing VAR1 you would do the following: ggplot() + geom_point(data = missing_df, aes(x = x, y = y, color = VAR1), shape = 17, size = 3) + coord_fixed() The shape and size assignments happen outside of aes, and so are applied equally to all observations. In some cases, you might want to let other aesthetic attributes vary with the values of a variable in the dataframe. For instance, if we let the sizes change with the value of the variable: ggplot() + geom_point(data = missing_df, aes(x = x, y = y, color = VAR1, size = VAR1), shape = 17) + coord_fixed() ## Warning: Removed 5 rows containing missing values (geom_point). Note how there is a warning, saying that five observations were removed because data were missing! These are likely the five locations where Observed == FALSE! To make it more clear which observations are these, you could set the shape to vary according to the value of Observed, as follows: ggplot() + geom_point(data = missing_df, aes(x = x, y = y, color = VAR1, shape = Observed), size = 3) + coord_fixed() You can change the coloring scheme by means of scale_color_distiller (you can can check the different color palettes available here): ggplot() + geom_point(data = missing_df, aes(x = x, y = y, color = VAR1, shape = Observed), size = 3) + scale_color_distiller(palette = &quot;RdBu&quot;) + coord_fixed() You will notice maybe that with this coloring scheme some observations become very light and difficult to distinguish from the background. This can be solved in many different ways (for instance, by changing the color of the background!). A simple fix is to add a layer with hollow symbols, as follows: ggplot() + geom_point(data = missing_df, aes(x = x, y = y, color = VAR1), shape = 17, size = 3) + geom_point(data = missing_df, aes(x = x, y = y), shape = 2, size = 3) + scale_color_distiller(palette = &quot;RdBu&quot;) + coord_fixed() Finally, you could try subsetting the data to have greater control of the appareance of your plot, for instance: ggplot() + geom_point(data = subset(missing_df, Observed == TRUE), aes(x = x, y= y, color = VAR1), shape = 17, size = 3) + geom_point(data = subset(missing_df, Observed == TRUE), aes(x = x, y= y), shape = 2, size = 3) + geom_point(data = subset(missing_df, Observed == FALSE), aes(x = x, y= y), shape = 18, size = 4) + scale_color_distiller(palette = &quot;RdBu&quot;) + coord_fixed() 5.9 Other Resources These are relatively simple maps, in fact not much more than scatterplots. If you would like to see different possibilities for creating maps in R, please visit a Shiny app that illustrates maps for different types of data. "],
["activity-2-statistical-maps-ii.html", "Chapter 6 Activity 2: Statistical Maps II 6.1 Housekeeping Questions 6.2 Learning objectives 6.3 Suggested reading 6.4 Preliminaries 6.5 Activity", " Chapter 6 Activity 2: Statistical Maps II Remember, you can download the source file for this activity from here. 6.1 Housekeeping Questions Answer the following questions: How many examinations are there in this course? What is the date of the first examination? Where is the office of your instructor? 6.2 Learning objectives In this activity you will: Learn about patterns and processes, including random patterns. Understand the general approach to retrieve a process from a pattern. Discuss the importance of discriminating random patterns. 6.3 Suggested reading O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapters 1-3. John Wiley &amp; Sons: New Jersey. 6.4 Preliminaries For this activity you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) library(geog4ga3) Now that your workspace is clear, you can proceed to invoke the datasets required for this activity: data(&quot;missing_df&quot;) data(&quot;PointPattern1&quot;) data(&quot;PointPattern2&quot;) data(&quot;PointPattern3&quot;) The datasets include the following dataframe which will be used in the first part of the activity: missing_df This dataframe includes \\(n = 65\\) observations (Note: text between $ characters is mathematical notation in LaTeX). These observations are geocoded using a false origin and coordinates normalized to the unit-square (the extent of their values is between zero and one). The coordinates are x and y. In addition, there are three variables associated with the locations (VAR1, VAR2, VAR3). The variables are generic. Feel free to think of them as if they were housing prices or concentrations in ppb of some contaminant. Finally, a factor variable states whether the variables were measured for a location: if the status is “FALSE”, the values of the variables are missing. The following dataframes will be used in the second part of the activity: PointPattern1 PointPattern2 PointPattern3 The dataframes PointPattern* are locations of some generic events. The coordinates x and y are also based on a false origin and are normalized to the unit-square. Feel free to think of these events as cases of flu, the location of trees of a certain species, or the location of fires. 6.5 Activity Create thematic maps for variables VAR1 through VAR3 in the dataframe missing_df. Suppose that you were tasked with estimating the value of a variable for the locations where those were not measured. For instance, you could be a realtor, and you need to assess the value of a property, and the only information available is the published values of other properties in the region. As an alternative, you could be an environmental scientist, and you need to estimate what the concentration of a contaminant at a site, based on previous measurements at other sites in the region. Propose one or more ways to guess those missing values, and explain your reasoning. The approach does not need to be the same for all variables! Plot all three point patterns. Imagine that you are a public health official and you need to plan services to the public. If you were asked to guess where the next event would emerge, where would be your guess in each map? Explain your answer. "],
["maps-as-processes-null-landscapes-spatial-processes-and-statistical-maps.html", "Chapter 7 Maps as Processes: Null Landscapes, Spatial Processes, and Statistical Maps 7.1 Learning Objectives 7.2 Suggested Readings 7.3 Preliminaries 7.4 Random Numbers 7.5 Null Landscapes 7.6 Stochastic Processes 7.7 Simulating Spatial Processes 7.8 Processes and Patterns", " Chapter 7 Maps as Processes: Null Landscapes, Spatial Processes, and Statistical Maps NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. In last practice your learning objectives were: How to obtain a descriptive summary of a dataframe. Factors and how to use them. How to subset a dataframe. Pipe operators and how to use them. How to improve your maps. Please review the previous practices if you need a refresher on these concepts. If you wish to work interactively with this chapter you will need the following: An R markdown notebook version of this document (the source file). 7.1 Learning Objectives In this chapter, you will learn: How to generate random numbers with different properties. About Null Landscapes. About stochastic processes. How to create new columns in a dataframe using a formula. How to simulate a spatial process. 7.2 Suggested Readings Bivand RS, Pebesma E, Gomez-Rubio V (2008) Applied Spatial Data Analysis with R, Analysing Spatial Data (pp. 169-171). Springer: New York. O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 4. John Wiley &amp; Sons: New Jersey. 7.3 Preliminaries As usual, it is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) 7.4 Random Numbers Colloquially, we understand random as something that happens in an unpredictable way. The same word in statistics has a precise meaning, as the outcome of a process that cannot be predicted with certainty. The question whether random processes exist is philosophically interesting. In the early stages of the invention of science, there was much optimism that humans could one day understand every aspect of the universe. This notion is well illustrated by Laplace’s Demon, a hypothetical entity that could predict the state of the universe in the future based on an all-encompassing knowledge of the state of the universe at any past point in time (see here). There are two important limitations to this perspective. First, there is the assumption that the mechanisms of operation of phenomena are well understood (in the case of Laplace’s Demon, it was somewhat naively assumed that classical Newtonian mechanics were sufficient). And secondly, the assumption that all relevant information is available to the observer. In reality, there are many processes that are not fully understood. Furthermore, there are often constraints in terms of how much information (and how accurately) can be collected with respect to any given phenomenon. A process can be deterministic. However, When limited knowledge/limited information prevent us from being able to make certain predictions, we assume that the process is random. It is important to note that “random” does not mean that just any outcome is possible. For instance, if you flip a coin, there are only two possible outcomes. If you roll a dice, there are only six possible outcomes. The concentration of a pollutant cannot be negative. The height of a human adult cannot be zero or 10 meters. And so on. Over time, many formulas have been devised to describe different types of random processes. A random probability distribution function describes the probability of observing different outcomes. For instance, a formula for processes similar to coin flips was discovered by Bernoulli in 1713 (see here). The following function reports a random binomial variable. The number of observations n is how many random numbers we require. The size is the number of trials. For instance, if the experiment was flipping a coin, it would be how many times we get heads in size flips. The probability of success prob is the probability of getting heads in any given toss. Execute the chunk repeatedly to see what happens. rbinom(n = 1, size = 1, prob = 0.5) ## [1] 1 If you tried this “experiment” repeatedly, you would find that “heads” (1s) and “tails” (0s) appear each about 50% of the time. A way to implement this is to increase n- think of this as recruiting more people to do coin flips at the same time: n &lt;- 1000 # Number of people tossing the coin one time. coin_flips &lt;- rbinom(n = n, size = 1, prob = 0.5) sum(coin_flips)/n ## [1] 0.5 What happens if you change the size to 0, and why? The binomial function is an example of a discrete probability distribution function, because it can take only one of a discrete (limited) number of values (0 and 1). Other random probability distribution functions are for continuous variables, variables that can take any value within a predefined range. The most famous of this distributions is the normal distribution, which you may know also as the bell curve, which is attributed to Gauss (see here). This distribution is defined by a centering paramater (its mean) and a spread parameter (its standard deviation). In the normal distribution, 68% of values are within one standard deviation from the mean, 95% of values are within two standard deviations from the mean, and 99.7% of values are within three standard deviations from the mean. The following function reports a value taken at random from a normal distribution with mean zero and standard deviation sd of one. Execute this chunk repeatedly to see what happens: rnorm(1, mean = 0, sd = 1) ## [1] 0.9995114 Let’s say that the average height of Canadian men is 170.7 cm and the standard deviation is 7 cm. The heigh of a random person in this population would be: rnorm(1, mean = 170.7, sd = 7) ## [1] 169.202 And the distribution of heights of n men in this population would be: n &lt;- 1000 height &lt;- rnorm(n, mean = 170.7, sd = 7) height &lt;- data.frame(height) ggplot(data = height, aes(x = height)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Men shorter than 150 cm would be extremely rare, as well as men taller than 190 cm. 7.5 Null Landscapes So what have random variables have to do with maps? Random variables can be used to generate purely random maps. These are called null landscapes or neutral landscapes in spatial ecology (With and King 1997) (Paper is available to download). The concept of null landscapes is quite useful, because they provide a benchmark to compare statistical maps. Let’s see how to generate a null landscape of events. Suppose that there is a landscape with coordinates in the unit square, that is divided in very small discrete units of land. Each of these units of land can be the location of an event. For example, a tree might be present; or a case of a disease. Let’s first create a landscape. For this, we will use the expand.grid function to find all combinations of two sets of coordinates in the unit interval, using small partitions: coords &lt;- expand.grid(x = seq(from = 0, to = 1, by = 0.05), y = seq(from = 0, to = 1, by = 0.05)) Now, let’s generate a binomial random variable to go with these coordinates. events &lt;- rbinom(n = nrow(coords), size = 1, prob = 0.5) We will collect the coordinates and the random variable in a dataframe for plotting: null_pattern &lt;- data.frame(coords, events) This is our null landscape: ggplot() + geom_point(data = subset(null_pattern, events == 1), aes(x = x, y = y), shape = 15) + coord_fixed() By changing the probability prob in the function rbinom you can make the event more or less frequent. If you are working with the notebook version of this document you can try changing the parameters! A continuous random variable can be used to generate a landscape with a null trend. For instance, imagine that a group of individuals are asked to stand in formation, and that they arrange themselves purely at random. What would a map of their heights look like? heights &lt;- rnorm(n = nrow(coords), mean = 170.7, sd = 7) Collecting in a dataframe for plotting: null_trend &lt;- data.frame(coords, heights) One possible map of heights when the individuals stand in formation at random would look like: ggplot() + geom_point(data = null_trend, aes(x = x, y = y, color = heights), shape = 15) + scale_color_distiller(palette = &quot;Spectral&quot;) + coord_fixed() These are only two of many possible techniques to generate null landscapes. We will discuss other later in the course. 7.6 Stochastic Processes Some processes are random, such as the ones used above to create null landscapes. These processes take values with some probability, but cannot be predicted with any certainty. Let’s illustrate using again a unit square: coords &lt;- expand.grid(x = seq(from = 0, to = 1, by = 0.05), y = seq(from = 0, to = 1, by = 0.05)) Here is an example of a random pattern of events: events &lt;- rbinom(n = nrow(coords), size = 1, prob = 0.5) null_pattern &lt;- data.frame(coords, events) ggplot() + geom_point(data = subset(null_pattern, events == 1), aes(x = x, y = y), shape = 15) + coord_fixed() A systematic or deterministic process is one that contains no elements of randomness, and can therefore be predicted with complete certainty. For instance (note the use of xlim to set the extent of x axis in the plot): deterministic_point_pattern &lt;- coords deterministic_point_pattern &lt;- mutate(deterministic_point_pattern, events = round(x)) ggplot() + geom_point(data = subset(deterministic_point_pattern, events == 1), aes(x = x, y = y), shape = 15) + xlim(0, 1) + coord_fixed() In the process above, I used the function round() and the coordinate x. The function gives a value of one for all points with x &gt; 0.5, and a value of zero to all points with x &lt;= 0.5. The pattern is fully deterministic: if I know the value of the x coordinate I can predict whether an event will be present. A stochastic process, on the other hand, is a process that is neither fully random or deterministic, but rather a combination of the two. Let’s illustrate: stochastic_point_pattern &lt;- coords stochastic_point_pattern &lt;- mutate(stochastic_point_pattern, events = round(x) - round(x) * rbinom(n = nrow(coords), size = 1, prob = 0.5)) ggplot() + geom_point(data = subset(stochastic_point_pattern, events == 1), aes(x = x, y = y), shape = 15) + xlim(0, 1) + coord_fixed() The process above has a deterministic component (the probability of an event is zero if x &lt;= 0.5), and a random component (the probability of a coordinate being an event is 0.5 when x &gt; 0.5). 7.7 Simulating Spatial Processes Null landscapes are interesting as a benchmark. More interesting are landscapes that emerge as the outcome of a non-random process- either a systematic/deterministic or stochastic process. Here we will see how to introduce a systematic element into a null landscape to simulate spatial processes. Let’s begin with the point pattern, using the same landscape that we used above. We will first copy the coordinates of the landscape to a new dataframe, that we will call pattern1: pattern1 &lt;- coords Next, we will use the function mutate from the dplyr package that is part of the tidyverse. This function adds a column to a data frame that could be calculated using a formula. For instance, we will now make the probability prob of the random binomial number generator a function of the coordinates: pattern1 &lt;- mutate(pattern1, events = rbinom(n = nrow(pattern1), size = 1, prob = (x))) Plot this pattern: ggplot() + geom_point(data = subset(pattern1, events == 1), aes(x = x, y = y), shape = 15) + coord_fixed() Since the probability of a “success” in the binomial experiment is proportional to the value of x (the coordinate of the event), now the events are clustered to the right of the plot. The underlying process in this case can be described in simple terms as “the probability of an event increases in the east direction”, possibly as a result of wind conditions, soil fertility, or other environmental factors that follow a trend. Let’s see what happens when we make this probability a function of the y coordinate: pattern1 &lt;- mutate(pattern1, events = rbinom(n = nrow(pattern1), size = 1, prob = (y))) ggplot() + geom_point(data = subset(pattern1, events == 1), aes(x = x, y = y), shape = 15) + coord_fixed() Since the probability of a “success” in the binomial experiment is proportional to the value of y (the coordinate of the event), now the events are clustered to the top. The probability could be the interaction of the two coordinates: pattern1 &lt;- mutate(pattern1, events = rbinom(n = nrow(pattern1), size = 1, prob = (x * y))) ggplot() + geom_point(data = subset(pattern1, events == 1), aes(x = x, y = y), shape = 15) + coord_fixed() Which of course means that the events cluster on the top-right corner. A somewhat more sophisticated example could make the probability a function of distance from the center of the region: pattern1 &lt;- coords pattern1 &lt;- mutate(pattern1, distance = sqrt((0.5 - x)^2 + (0.5 - y)^2), events = rbinom(n = nrow(pattern1), size = 1, prob = 1 - exp(-0.5 * distance))) Don’t worry too much about the formula that I selected to generate this process; we will see different tools to describe a spatial process. In this particular example, I selected a function that makes the probability increase with distance from the center of the region. Plot this pattern: ggplot() + geom_point(data = subset(pattern1, events == 1), aes(x = x, y = y), shape = 15) + coord_fixed() As you would expect, there are few events near the center, and the number of events tends to increase away from the center. To conclude this practice, let’s revisit the example of the people standing in formation, but now their sorting is not random, since taller people tend to stand towards the back. We can simulate this by making the height a function of position. First, we copy the coordinates to a new dataframe for our trend experiment: trend1 &lt;- coords Again we use mutate to add a column to a data frame that could be calculated using a formula. For instance, we will now make the probability prob of the random binomial number generator a function of the coordinates: trend1 &lt;- mutate(trend1, heights = 160 + 20 * y + rnorm(n = nrow(pattern1), mean = 0, sd = 7)) If people have a preference for standing next to people about their same height, and shorter people have a preference for standing near the front, this is a possible map of heights in the formation: ggplot() + geom_point(data = trend1, aes(x = x, y = y, color = heights), shape = 15) + scale_color_distiller(palette = &quot;Spectral&quot;) + coord_fixed() As expected, shorter people are towards the “front” (bottom of the plot) and taller people towards the back. It is not a uniform process, since there is still some randomness, but a trend can be clearly appreciated. 7.8 Processes and Patterns O’Sullivan and Unwin (2010) make an important distinction between processes and patterns. A process is like a recipe, a sequence of events or steps, that leads to an outcome, that is, a pattern. You can think of the simulation procedures above as having two components: the process is the formula, function, or algorithm used to simulate a pattern. For instance, a random process could be based on the binomial distribution, whereas a stochastic process would have in addition to a random component some deterministic elements. The pattern is the outcome of the process. In the case of spatial processes, the outcome is typically a statistical map. The procedures in the preceding sections illustrate just a few different ways to simulate spatial processes with the aim of generating statistical maps that display spatial patterns. There are in fact many more ways to simulate spatial processes, and articles (e.g., Geyer and Møller 1994) - and even books (e.g., Moller and Waagepetersen 2003) - have been written on this topic! Simulation is a very valuable tool in spatial statistics, as we shall see in later chapters. It is important to note, however, that in the vast majority of cases we do not actually know the process; that is precisely what we wish to infer. Understanding process generation in a statistical sense, as well as null landscapes, is a useful tool that can help us to infer processes in applications with empirical (as opposed to simulated) data. In this sense, spatial statistics is often a tool used to make decisions about spatial patterns: are they random? And, if they are not random, can we infer the underlying process? Please visit app to explore different examples of spatial processes. Notice that some look more random and some look more systematic. At which point do you think a pattern ceases being random? References "],
["activity-3-maps-as-processes.html", "Chapter 8 Activity 3: Maps as Processes 8.1 Practice questions 8.2 Learning objectives 8.3 Suggested reading 8.4 Preliminaries 8.5 Activity", " Chapter 8 Activity 3: Maps as Processes Remember, you can download the source file for this activity from here. 8.1 Practice questions Answer the following questions: What is a Geographic Information System? What distinguishes a statistical map from other types of mapping techniques? What is a null landscape? 8.2 Learning objectives In this activity, you will: Simulate landscapes using various types of processes. Discuss the difference between random and non-random landscapes. Think about ways to decide whether a landscape is random. 8.3 Suggested reading O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 4. John Wiley &amp; Sons: New Jersey. 8.4 Preliminaries For this activity you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) In the practice that preceded this activity, you learned how to simulate null landscapes and spatial processes. 8.5 Activity Simulate and plot a landscape using a random, stochastic, or deterministic process. It is your choice whether to simulate a point pattern or a continuous variable. Share the map with a fellow student, and ask them to guess whether the map is random or non-random. Repeat steps 1 and 2 several times (depending on time, between two and four times). Propose one or more ways to decide whether a landscape is random, and explain your reasoning. The approach does not need to be the same for point patterns and continuous variables! "],
["point-pattern-analysis-i.html", "Chapter 9 Point Pattern Analysis I 9.1 Learning Objectives 9.2 Suggested Readings 9.3 Preliminaries 9.4 Point Patterns 9.5 Processes and Point Patterns 9.6 Intensity and Density 9.7 Quadrats and Density Maps 9.8 Defining the Region for Analysis", " Chapter 9 Point Pattern Analysis I NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. In last practice your learning objectives were: How to generate random numbers with different properties. About Null Landscapes. How to create new columns in a dataframe using a formula. How to simulate a spatial process. Please review the previous practices if you need a refresher on these concepts. If you wish to work interactively with this chapter you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. 9.1 Learning Objectives In this practice, you will learn: A formal definition of point pattern. Processes and point patterns. The concepts of intensity and density. The concept of quadrats and how to create density maps. More ways to control the look of your plots, in particular faceting and adding lines. 9.2 Suggested Readings Bailey TC and Gatrell AC (1995) Interactive Spatial Data Analysis, Chapter 3. Longman: Essex. Baddeley A, Rubak E, Turner R (2016) Spatial Point Pattern: Methodology and Applications with R, Chapter 1, 1.1 - 1.2. CRC: Boca Raton. Bivand RS, Pebesma E, Gomez-Rubio V (2008) Applied Spatial Data Analysis with R, Chapter 7. Springer: New York. Brunsdon C and Comber L (2015) An Introduction to R for Spatial Analysis and Mapping, Chapter 6, 6.1 - 6.6. Sage: Los Angeles. O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 5. John Wiley &amp; Sons: New Jersey. 9.3 Preliminaries As usual, it is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) library(spatstat) library(geog4ga3) Load the data that you will use for this practice: data(&quot;PointPatterns&quot;) Quickly check the contents of this dataframe: summary(PointPatterns) ## x y Pattern ## Min. :0.0169 Min. :0.005306 Pattern 1:60 ## 1st Qu.:0.2731 1st Qu.:0.289020 Pattern 2:60 ## Median :0.4854 Median :0.550000 Pattern 3:60 ## Mean :0.5074 Mean :0.538733 Pattern 4:60 ## 3rd Qu.:0.7616 3rd Qu.:0.797850 ## Max. :0.9990 Max. :0.999808 The dataframe contains the x and y coordinates of four different patterns of points, each with \\(n=60\\) events. 9.4 Point Patterns Previously you created different types of maps and learned about different kinds of processes (i.e., random, stochastic, deterministic). A map that you have seen in several occasions is one where the coordinates of an even of interest are available. The simplest kind of data of this type is when only the coordinates are available: we call this a point pattern. A point pattern is given by a set of events of interest that are observed in a region \\(R\\). A region has an infinite number of points, essentially coordinates \\((x_i, y_i)\\) on the plane. The number of points is infinite, because there is a point defined by, say, coordinates (1,1), and also a point for coordinates (1.1,1), and for coordinates for (1.01,1), and so on. Any location that can be described by a set of coordinates contained in the region is a point. Not all points are events, however. An event is defined as a point where something of interest happened. This could be the location where a tree exists, or a crime happened, the epicenter of an earthquake, a case of a disease was reported, and so on. There might be one such occurrence, or more. Each event is be denoted by: \\[ \\textbf{s}_i \\] with coordinates: \\[ (x_i,y_i). \\] Sometimes other attributes of the events have been measured as well. For example, the event could be an address where cholera was reported (as in John Snow’s famous map). In addition to the address (which can be converted into the coordinates of the event), the number of cases could be recorded. Other examples could be the height and diameter of trees, the magnitude of an earthquake, and so on. It is important, for reasons that will be discussed later, that the point pattern is a complete enumeration. What this means is that every event that happened has been recorded! Interpretation of most analysis becomes dubious if the events are only sampled, that is, if only a few of them have been recorded. 9.5 Processes and Point Patterns Point patterns are interesting in many applications. In these application, a key question of interest is whether the pattern is random. Imagine, for instance, a point pattern that records crimes in a region. The pattern might be random, in which case there is no way to anticipate where the next occurrence will be. Non-random patterns, on the other hand, are likely the outcome of some meaningful process. For instance, crimes might cluster as a consequence of some common environmental variable (e.g., concentration of wealth). On the contrary, they might repeal each other (e.g., the location of a crime draws attention of law enforcement, and therefore the next occurrence of a crime tends to happen away from it). Deciding whether the pattern is random or not is the initial step towards developing hypotheses about the underlying process. Consider for example the following patterns. To create the following figure, you can use faceting by means of ggplot2::facet_grid: ggplot() + geom_point(data = PointPatterns, aes(x = x, y = y)) + facet_grid(.~ Pattern) + coord_fixed() As you can see, faceting is a convenient way to simultaneously plot different parts of a dataframe (in the present case, the different Patterns). In the preceding activity, you were asked to generate ideas regarding possible ways of deciding whether a map of events (i.e., a point pattern) is random. In this chaper we will formalize a specific idea to do so, concretely by considering the intensity of the process. This is discussed in more detail next. 9.6 Intensity and Density The intensity of a spatial point process is the expected number of events per unit area. This is conventionally denoted by the greek letter \\(\\lambda\\). In most cases the process is not know, so its intensity cannot be directly measured. In its place, the density of the point pattern is taken as the empirical estimate of the intensity of the underlying process. The density of the point pattern is calculated very simply as the number of events divided by the area of the region, that is: \\[ \\hat{\\lambda} = \\frac{(S \\in R)}{a} = \\frac{n}{a}. \\] Notice the use of the “hat” symbol on top of the Greek lambda. This symbol is called “caret”. The hat notation is used to indicate an estimated value of an unobserved parameter of a process, in the present case the intensity of the spatial point process. Consider one of the point patterns in your sample dataset, say “Pattern 1”. Let’s summarize it: summary(subset(PointPatterns, Pattern == &quot;Pattern 1&quot;)) ## x y Pattern ## Min. :0.0285 Min. :0.005306 Pattern 1:60 ## 1st Qu.:0.3344 1st Qu.:0.236509 Pattern 2: 0 ## Median :0.5247 Median :0.500262 Pattern 3: 0 ## Mean :0.5531 Mean :0.500248 Pattern 4: 0 ## 3rd Qu.:0.8417 3rd Qu.:0.761218 ## Max. :0.9888 Max. :0.999808 We see that there are \\(n = 60\\) points in this dataset. Since the region is the unit square (check how the values of the coordinates range from approximately zero to approximately 1), the area of the region is 1. This means that for “Pattern 1”: \\[ \\hat{\\lambda} = \\frac{60}{1} = 60 \\] This is the overall density of the point pattern. 9.7 Quadrats and Density Maps The overall density of a point process (calculated above) can be mapped by means of the geom_bin2d function of the ggplot2 package. This function divides two dimensional space into bins and reports the number of events or the density of the events in the bins. Let’s give this a try: ggplot() + geom_bin2d(data = subset(PointPatterns, Pattern == &quot;Pattern 1&quot;), aes(x = x, y = y), binwidth = c(1, 1)) + coord_fixed() Let’s see step-by-step how this plot is made. ggplot() creates a plot object. geom_bin2d is called to plot a map of counts of events in the space defined by the bins. The dataframe used for plotting the bins is PointPatterns, subset so that only the points in “Pattern 1” are used. The coordinates x and y are used to plot (in aes(), we indicate that x in the dataframe corresponds to the x axis in the plot, and y in the dataframe corresponds to y axis in the plot) The size of the bin is defined as 1-by-1 (binwidth = c(1, 1)) coord_fixed is applied to ensure that the aspect ratio of the plot is one (one unit of x is the same length as one unit of y in the plot). The map of the overall density of the process above is not terribly interesting. It only reports what we already knew, that globally the density of the point pattern is 60. It would be more interesting to see how the density varies across the region. We do this by means of the concept of quadrats. Imagine that instead of calculating the overall (or global) intensity of the point pattern, we subdivided the region into a set of smaller subregions. For instance, we could draw horizontal and vertical lines to create smaller squares: ggplot() + geom_vline(xintercept = seq(from = 0, to = 1, by = 0.25)) + geom_hline(yintercept = seq(from = 0, to = 1, by = 0.25)) + geom_point(data = subset(PointPatterns, Pattern == &quot;Pattern 1&quot;), aes(x = x, y = y)) + coord_fixed() Notice the following functions used to create the vertical lines (geom_vline) and horizontal lines (geom_hline), from 0 to 1 every 0.25 units of distance respectively. Each of the smaller squares used to subdivide the region is called a quadrat. To make things more interesting, instead of calculating the overall density, we can calculate the density for each quadrat. Let’s visualize a density map using quadrats: ggplot() + geom_bin2d(data = subset(PointPatterns, Pattern == &quot;Pattern 1&quot;), aes(x = x, y = y), binwidth = c(0.50, 0.50)) + geom_point(data = subset(PointPatterns, Pattern == &quot;Pattern 1&quot;), aes(x = x, y = y)) + scale_fill_distiller(palette = &quot;RdBu&quot;) + coord_fixed() You can, of course, change the size of the quadrats. Let’s take a look at the four point patterns (by means of faceting), after creating a variable to easily control the size of the quadrat. Let’s call this variable q_size: q_size &lt;- 0.25 ggplot() + geom_bin2d(data = PointPatterns, aes(x = x, y = y), binwidth = c(q_size, q_size)) + geom_point(data = PointPatterns, aes(x = x, y = y)) + facet_grid(.~ Pattern) + scale_fill_distiller(palette = &quot;RdBu&quot;) + coord_fixed() Notice the differences in the density maps? Try changing the size of the quadrat to 1. What happens, and why? Next, try a smaller quadrat size, say 0.25. What happens, and why? Try even smaller quadrat sizes, but greater than zero. What happens now? The package spatstat includes numerous functions for the analysis of point patterns. A relevant function at this point, is quadratcount, which returns the number of events per quadrat. To use this function, we need to convert the point patterns to a type of data used by spatstat denominated ppp (for plannar point pattern). This is simple, thanks to a utility function in spatstat called as.ppp. This function takes as arguments (inputs) a set of coordinates, and data to define a window. Let’s convert the spatial patterns to ppp objects. First, define the window by means of the owin function, and using the 0 to 1 interval for our region: Wnd &lt;- owin(c(0,1), c(0,1)) Now, a ppp object can be created: ppp1 &lt;- as.ppp(PointPatterns, Wnd) If you examine these new ppp objects, you will see that they pack the same basic information (i.e., the coordinates), but also the range of the region and so on: summary(ppp1) ## Marked planar point pattern: 240 points ## Average intensity 240 points per square unit ## ## Coordinates are given to 8 decimal places ## ## Multitype: ## frequency proportion intensity ## Pattern 1 60 0.25 60 ## Pattern 2 60 0.25 60 ## Pattern 3 60 0.25 60 ## Pattern 4 60 0.25 60 ## ## Window: rectangle = [0, 1] x [0, 1] units ## Window area = 1 square unit As you can see, the ppp object includes the four patterns, calculates the frequency of each (the number of events), and their respective overall intensities. Objects of the class ppp can be plotted using base plotting functions: plot(ppp1) To plot each pattern separately you can split the different patterns using the function split.ppp(). Notice how $ works for indexing the patterns here: plot(split.ppp(ppp1)$`Pattern 1`) Once the patterns are in ppp form, quadratcount can be used to compute the counts of events. To calculate the count separately for each pattern, you need to use again split.ppp() (if you don’t index a pattern, it will apply the function to all of them). The other two arguments are the number of quadrats in the horizontal (nx) and the vertical (ny) directions: quadratcount(split(ppp1), nx = 4, ny = 4) ## List of spatial objects ## ## Pattern 1: ## x ## y [0,0.25) [0.25,0.5) [0.5,0.75) [0.75,1] ## [0.75,1] 3 5 1 6 ## [0.5,0.75) 2 3 4 6 ## [0.25,0.5) 5 4 2 3 ## [0,0.25) 2 4 4 6 ## ## Pattern 2: ## x ## y [0,0.25) [0.25,0.5) [0.5,0.75) [0.75,1] ## [0.75,1] 14 2 2 6 ## [0.5,0.75) 0 0 4 6 ## [0.25,0.5) 6 3 1 2 ## [0,0.25) 4 6 2 2 ## ## Pattern 3: ## x ## y [0,0.25) [0.25,0.5) [0.5,0.75) [0.75,1] ## [0.75,1] 2 11 5 7 ## [0.5,0.75) 1 1 6 4 ## [0.25,0.5) 1 10 3 2 ## [0,0.25) 2 1 2 2 ## ## Pattern 4: ## x ## y [0,0.25) [0.25,0.5) [0.5,0.75) [0.75,1] ## [0.75,1] 4 5 6 3 ## [0.5,0.75) 3 3 4 2 ## [0.25,0.5) 3 3 4 2 ## [0,0.25) 5 4 6 3 Compare the counts of the quadrats for each pattern. They should replicate what you observed in the density plots before. 9.8 Defining the Region for Analysis It is important when conducting the type of analysis described above (and more generally any analysis with point patterns), to define a region for analysis that is consistent with the pattern of interest. Consider for instance what would happen if the region was defined, instead of in the unit square, as a bigger region. Create a second window: Wnd2 &lt;- owin(c(-1,2), c(-1,2)) Create a second ppp object using this new window: ppp2 &lt;- as.ppp(PointPatterns, Wnd2) Repeat the plot but using the new ppp object: plot(split.ppp(ppp2)$`Pattern 1`) Repeat but now using an even bigger region. Create a third window: Wnd3 &lt;- owin(c(-2, 3), c(-2, 3)) And also a third ppp object using the third window: ppp3 &lt;- as.ppp(PointPatterns, Wnd3) Now the plot looks like this: plot(split.ppp(ppp3)$`Pattern 1`) Which of the three regions that you saw above is more appropriate? What do you think is the effect of selecting an inappropriate region for the analysis? This concludes this chapter. The next activity will illustrate how quadrats are a useful tool to explore the question whether a map is random. "],
["activity-4-point-pattern-analysis-i.html", "Chapter 10 Activity 4: Point Pattern Analysis I 10.1 Practice questions 10.2 Learning objectives 10.3 Suggested reading 10.4 Preliminaries 10.5 Activity", " Chapter 10 Activity 4: Point Pattern Analysis I Remember, you can download the source file for this activity from here. 10.1 Practice questions Answer the following questions: What is a random process? What is a deterministic process? What is a stochastic process? What is a pattern? What is the usefulness of a null landscape? 10.2 Learning objectives In this activity, you will: Use the concept of quadrats to analyze a real dataset. Learn about a quadrat-based test for randomness in point patterns. Learn how to use the p-value of a statistical test to make a decision. Think about the distribution of events in a null landscape. Think about ways to decide whether a landscape is random. 10.3 Suggested reading O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 5. John Wiley &amp; Sons: New Jersey. 10.4 Preliminaries For this activity you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity. In addition to tidyverse, you will need spatstat, a package designed for the analysis of point patterns (you can learn about spatstat here and here): library(tidyverse) library(spatstat) library(maptools) # Needed to convert a `Spatial Polygons` object into an `owin` object library(sf) library(geog4ga3) In the practice that preceded this activity, you learned about the concepts of intensity and density, about quadrats, and also how to create density maps. Begin by loading the data that you will use in this activity: data(&quot;Fast_Food&quot;) data(&quot;Gas_Stands&quot;) data(&quot;Paez_Mart&quot;) Next the geospatial files need to be read. For this example, the city boundary of Toronto is provided in two different formats, as a dataframe (which can be used to plot using ggplot2) and as a SpatialPolygons object, a format widely used in R for spatial analysis. The : data(&quot;Toronto&quot;) If you inspect your workspace, you will see that the following dataframes are there: Fast_Food Gas_Stands Paez_Mart These are locations of a selection of fast food restaurants, and also of gas stands in Toronto (data are from 2008). Paez Mart on the other hand is a project to cover Toronto with convenience stores. The points are the planned locations of the stores. Also, there should be an object of class sf. This dataframe contains the city boundary of Toronto: class(Toronto) ## [1] &quot;sf&quot; &quot;data.frame&quot; Try plotting the following: ggplot() + geom_sf(data = Toronto, color = &quot;black&quot;, fill = NA, alpha = 1, size = .3) + geom_sf(data = Paez_Mart) + coord_sf() As discussed in the preceding chapter, the package spatstat is a very rich collection of tools to do point pattern analysis. To convert the three sets of events (i.e., the fast food establishments, gas stands, and Paez Mart) into ppp objects we first must define a region or window. To do this we take the sf and convert to an owin (a window object) for use with the package spatstat (this is done via SpatialPolygons, hence as(x, &quot;Spatial&quot;): Toronto.owin &lt;- as.owin(as(Toronto, &quot;Spatial&quot;)) # Requires `maptools` package And, then convert the dataframes to ppp objects (this necessitates that we extract the coordinates of the events by means of st_coordinates): Fast_Food.ppp &lt;- as.ppp(st_coordinates(Fast_Food), W = Toronto.owin) Gas_Stands.ppp &lt;- as.ppp(st_coordinates(Gas_Stands), W = Toronto.owin) Paez_Mart.ppp &lt;- as.ppp(st_coordinates(Paez_Mart), W = Toronto.owin) These objects can now be used with the functions of the spatstat package. For instance, you can calculate the counts of events by quadrat by means of quadrat.count. The input must be a ppp object, and the number of quadrats on the horizontal (nx) and vertical (ny) direction (notice how I use the function table to present the frequency of quadrats with number of events): q_count &lt;- quadratcount(Fast_Food.ppp, nx = 3, ny = 3) table(q_count) ## q_count ## 0 6 44 48 60 64 85 144 163 ## 1 1 1 1 1 1 1 1 1 As you see from the table, there is one quadrat with zero events, one quadrat with six events, one quadrat with forty-four events, and so on. You can also plot the results of the quadratcount! plot(q_count) A useful function in the spatstat package is quadrat.test. This function implements a statistical test that compares the empirical distribution of events by quadrats to the distribution of events as expected under the hypothesis that the underlying process is random. This is implemented as follows: q_test &lt;- quadrat.test(Fast_Food.ppp, nx = 3, ny = 3) ## Warning: Some expected counts are small; chi^2 approximation may be ## inaccurate q_test ## ## Chi-squared test of CSR using quadrat counts ## Pearson X2 statistic ## ## data: Fast_Food.ppp ## X2 = 213.74, df = 8, p-value &lt; 2.2e-16 ## alternative hypothesis: two.sided ## ## Quadrats: 9 tiles (irregular windows) The quadrat test reports a \\(p\\)-value which can be used to make a decision. The \\(p\\)-value is the probability that you will be mistaken if you reject the null hypothesis. To make a decision, you need to know what is the null hypothesis, and your own tolerance for making a mistake. In the case above, the \\(p\\)-value is very, very small (2.2e-16 = 0.00000000000000022). Since the null hypothesis is spatial randomness, you can reject this hypothesis and the probability that this decision is mistaken is vanishingly small. Try plotting the results of quadrat.test: plot(q_test) Now that you have seen how to do some analysis using quadrats, you are ready for the next activity. 10.5 Activity Use Fast_Food, Gas_Stands, Paez_Mart, and Toronto to create density maps for the three point patterns. Select a quadrat size that you think is appropriate. Show your maps to a fellow student. Did they select the same quadrat size? If not, what was their rationale for their size? Use Fast_Food.ppp, Gas_Stands, and Paez_Mart, and the function quadratcount to calculate the number of events per quadrat. Remember that you need to select the number of quadrats in the horizontal and vertical directions! Use the function table() to examine the frequency of events per quadrat for each of the point patterns. What are the differences among these point patterns? What would you expect the frequency of events per quadrat to be in a null landscape? Use Fast_Food.ppp, Gas_Stands, and Paez_Mart, and the function quadrat.test to calculate the test of spatial independence for these point patterns. What is your decision in each case? "],
["point-pattern-analysis-ii.html", "Chapter 11 Point Pattern Analysis II 11.1 Learning Objectives 11.2 Suggested Readings 11.3 Preliminaries 11.4 A Quadrat-based Test for Spatial Independence 11.5 Limitations of Quadrat Analysis: Size and Number of Quadrats 11.6 Limitations of Quadrat Analysis: Relative Position of Events 11.7 Kernel Density", " Chapter 11 Point Pattern Analysis II NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. In the last practice/session your learning objectives included: A formal definition of point pattern. Processes and point patterns. The concepts of intensity and density. The concept of quadrats and how to create density maps. More ways to control the look of your plots, in particular faceting and adding lines. Please review the previous practices if you need a refresher on these concepts. If you wish to work interactively with this chapter you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. 11.1 Learning Objectives In this practice, you will learn: The intuition behind the quadrat-based test of independence. About the limitations of quadrat-based analysis. The concept of kernel density. More ways to manipulate objects to do point pattern analysis using spatstat. 11.2 Suggested Readings Bailey TC and Gatrell AC (1995) Interactive Spatial Data Analysis, Chapter 3. Longman: Essex. Baddeley A, Rubak E, Turner R (2016) Spatial Point Pattern: Methodology and Applications with R, Chapter 6. CRC: Boca Raton. Bivand RS, Pebesma E, Gomez-Rubio V (2008) Applied Spatial Data Analysis with R, Chapter 7. Springer: New York. Brunsdon C and Comber L (2015) An Introduction to R for Spatial Analysis and Mapping, Chapter 6, 6.1 - 6.6. Sage: Los Angeles. O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 5. John Wiley &amp; Sons: New Jersey. 11.3 Preliminaries As usual, it is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) library(spatstat) library(geog4ga3) Load the datasets that you will use for this practice: data(&quot;PointPatterns&quot;) data(&quot;pp0_df&quot;) PointPatterns is a dataframe with four sets of spatial events, labeled as “Pattern 1”, “Pattern 2”, “Pattern 3”, and “Pattern 4”. Each set has \\(n=60\\) events. You can check the class of this object by means of the function class class(). class(PointPatterns) ## [1] &quot;data.frame&quot; The second dataframe (i.e., pp0_df) includes the coordinates x and y of two sets of spatial events, labeled as “Pattern 1” and “Pattern 2”. The summary for PointPatterns shows that these point patterns are located in a square-unit window (check the max and min values of x and y): summary(PointPatterns) ## x y Pattern ## Min. :0.0169 Min. :0.005306 Pattern 1:60 ## 1st Qu.:0.2731 1st Qu.:0.289020 Pattern 2:60 ## Median :0.4854 Median :0.550000 Pattern 3:60 ## Mean :0.5074 Mean :0.538733 Pattern 4:60 ## 3rd Qu.:0.7616 3rd Qu.:0.797850 ## Max. :0.9990 Max. :0.999808 The same is true for pp0_df: summary(pp0_df) ## x y marks ## Min. :0.0456 Min. :0.03409 Pattern 1:36 ## 1st Qu.:0.2251 1st Qu.:0.22963 Pattern 2:36 ## Median :0.4282 Median :0.43363 ## Mean :0.4916 Mean :0.47952 ## 3rd Qu.:0.7812 3rd Qu.:0.77562 ## Max. :0.9564 Max. :0.94492 As seen in the previous practice and activity, the package spatstat employs a type of object called ppp (for planar point pattern). Fortunately, it is relatively simple to convert a dataframe into a ppp object by means of as.ppp(). This function requires that you define a window for the point pattern, something we can do by means of the owin function: W &lt;- owin(xrange = c(0, 1), yrange = c(0, 1)) Then the dataframes are converted using the as.ppp function: pp0.ppp &lt;- as.ppp(pp0_df, W = W) PointPatterns.ppp &lt;- as.ppp(PointPatterns, W = W) You can verify that the new objects are indeed of ppp-class: class(pp0.ppp) ## [1] &quot;ppp&quot; class(PointPatterns.ppp) ## [1] &quot;ppp&quot; 11.4 A Quadrat-based Test for Spatial Independence In the preceding activity, you used a quadrat-based spatial independence test to help you decide whether a pattern was random (the function was quadrat.test). We will now review the intuition of the test. Let’s begin by plotting the patterns. You can use split to do plots for each pattern separately, instead of putting all of them in a single plot (these plots are not as responsive as ggplot2 but are quick): plot(split(PointPatterns.ppp)) Recall that you can also plot individual patterns by using $ followed by the factor that identifies the desired pattern (this is a way of indexing different patterns in ppp-class objects): plot(split(PointPatterns.ppp)$&quot;Pattern 4&quot;) Now calculate the quadrat-based test of independence: q_test &lt;- quadrat.test(split(PointPatterns.ppp)$&quot;Pattern 2&quot;, nx = 3, ny = 3) q_test ## ## Chi-squared test of CSR using quadrat counts ## Pearson X2 statistic ## ## data: split(PointPatterns.ppp)$&quot;Pattern 2&quot; ## X2 = 48, df = 8, p-value = 1.976e-07 ## alternative hypothesis: two.sided ## ## Quadrats: 3 by 3 grid of tiles Plot the results of the quadrat test: plot(q_test) As seen in the preceding chapter, the expected distribution of events on quadrats under the null landscape tends to be quite even. This is because each quadrat has equal probability of having the same number of events (depending on size, when the quadrats are not all the same size). If you check the plot of the quadrat test above, you will notice that the first number (top left corner) is the number of events in the quadrat. The second number (top right corner) is the expected number of events for a null landscape. The third number is a residual, based on the difference between the observed and expected number of events. More specifically, the residual is a Pearson residual, defined as follows: \\[ r_i=\\frac{O_i - E_i}{\\sqrt{E_i}}, \\] where \\(O_i\\) is the number of observed events in quadrat \\(i\\) and \\(E_i\\) is the number of expected events in quadrat \\(i\\). When the number of observed events is similar to the number of expected events, \\(r_i\\) will tend to be a small value. As the difference grows, the residual will also grow. The independence test is calculated from the residuals as: \\[ X2=\\sum_{i=1}^{Q}r_i^2, \\] where \\(Q\\) is the number of quadrats. In other words, the test is based on the squared sum of the Pearson residuals. The smaller this number is, the more likely that it is not different from the null landscape (i.e., a random process), and the larger it is, the more likely that it is different from the null landscape. This is reflected by the p-value of the test (technically, the p-value is obtained from comparing the test to the Chi-square distribution). Consider for instance the first pattern in the examples: plot(quadrat.test(split(PointPatterns.ppp)$&quot;Pattern 1&quot;, nx = 3, ny = 3)) You can see that the Pearson residual of the top left quadrat is indeed -0.6567673, the next to its right is -0.2704336, and so on. The value of the test statistic should be then: paste(&quot;X2 = &quot;, (-0.65)^2 + (-0.26)^2 + (0.52)^2 + (-0.26)^2 + (0.9)^2 + (0.52)^2 + (-1)^2 + (0.13)^2 + (0.13)^2) ## [1] &quot;X2 = 2.9423&quot; Which you can confirm by examining the results of the test (the small difference is due to rounding errors): quadrat.test(split(PointPatterns.ppp)$&quot;Pattern 1&quot;, nx = 3, ny = 3) ## ## Chi-squared test of CSR using quadrat counts ## Pearson X2 statistic ## ## data: split(PointPatterns.ppp)$&quot;Pattern 1&quot; ## X2 = 3, df = 8, p-value = 0.1313 ## alternative hypothesis: two.sided ## ## Quadrats: 3 by 3 grid of tiles Explore the remaining patterns. You will notice that the residuals and test statistic tend to grow as more events are concentrated in space. In this way, the test is a test of density of the quadrats: is their density similar to what would be expected from a null landscape? 11.5 Limitations of Quadrat Analysis: Size and Number of Quadrats As hinted by the previous activity, one issue with quadrat analysis is the selection of the size for the quadrats. Changing the size of the quadrats has an impact on the counts, and in turn on the aspect of density plots and even the results of the test of independence. For example, the results of the test for “Pattern 2” in the dataset change when the number of quadrats is modified. For instance, with a small number of quadrats: quadrat.test(split(PointPatterns.ppp)$&quot;Pattern 2&quot;, nx = 2, ny = 1) ## ## Chi-squared test of CSR using quadrat counts ## Pearson X2 statistic ## ## data: split(PointPatterns.ppp)$&quot;Pattern 2&quot; ## X2 = 1.6667, df = 1, p-value = 0.3934 ## alternative hypothesis: two.sided ## ## Quadrats: 2 by 1 grid of tiles Compare to four quadrats: quadrat.test(split(PointPatterns.ppp)$&quot;Pattern 2&quot;, nx = 2, ny = 2) ## ## Chi-squared test of CSR using quadrat counts ## Pearson X2 statistic ## ## data: split(PointPatterns.ppp)$&quot;Pattern 2&quot; ## X2 = 6, df = 3, p-value = 0.2232 ## alternative hypothesis: two.sided ## ## Quadrats: 2 by 2 grid of tiles And: quadrat.test(split(PointPatterns.ppp)$&quot;Pattern 2&quot;, nx = 3, ny = 2) ## ## Chi-squared test of CSR using quadrat counts ## Pearson X2 statistic ## ## data: split(PointPatterns.ppp)$&quot;Pattern 2&quot; ## X2 = 23.2, df = 5, p-value = 0.0006182 ## alternative hypothesis: two.sided ## ## Quadrats: 3 by 2 grid of tiles Why is the statistic generally smaller when there are fewer quadrats? A different issue emerges when the number of quadrats is large: quadrat.test(split(PointPatterns.ppp)$&quot;Pattern 2&quot;, nx = 4, ny = 4) ## Warning: Some expected counts are small; chi^2 approximation may be ## inaccurate ## ## Chi-squared test of CSR using quadrat counts ## Pearson X2 statistic ## ## data: split(PointPatterns.ppp)$&quot;Pattern 2&quot; ## X2 = 47.2, df = 15, p-value = 6.84e-05 ## alternative hypothesis: two.sided ## ## Quadrats: 4 by 4 grid of tiles A warning now tells you that some expected counts are small: space has been divided so minutely, that the expected number of events per quadrat has become too thin; as a consequence, the approximation to the probability distribution may be inaccurate. While there are no hard rules to select the size/number of quadrats, the following rules of thumb are sometimes suggested: Each quadrat should have a minimum of two events. The number of quadrats is selected based on the area (A) of the region, and the number of events (n): \\[ Q=\\frac{2A}{N} \\] Caution should be exercised when interpreting the results of the analysis based on quadrats, due to the issue of size/number of quadrats. 11.6 Limitations of Quadrat Analysis: Relative Position of Events Another issue with quadrat analysis is its insensibility to the relative position of the events within the quadrats. Consider for instance the following two patterns in pp0: plot(split(pp0.ppp)) These two patterns look quite different. And yet, when we count the events by quadrats: plot(quadratcount(split(pp0.ppp), nx = 3, ny = 3)) This example highlights how quadrats are relatively coarse measures of density, and fail to distinguish between fairly different event distributions, in particular because quadrat analysis does not take into account the relative position of the events with respect to each other. 11.7 Kernel Density In order to better take into account the relative position of the events with respect to each other, a different technique can be devised. Imagine that a quadrat is a kind of “window”. We use it to observe the landscape. When we count the number of events in a quadrat, we simply peek through that particular window: all events inside the “window” are simply counted, and all events outside the “window” are ignored. Then we visit another quadrat and do the same, until we have visited all quadrats. Imagine now that we define a window that, unlike the quadrats which are fixed, can move and visit different points in space. This window also has the property that, instead of counting the events that are in the window, it gives greater weight to events that are close to the center of the window, and less weight to events that are more distant from the center of the window. We can define such a window by selecting a function that declines with increasing distance. We will call this function a kernel. An example of a function that can work as a moving window is the following. ggplot(data = data.frame(dist = c(-3, 3)), aes(dist)) + stat_function(fun = dnorm, n = 101, args = list(mean = 0, sd = 1)) + ylim(c(0, 0.45)) As you can see, the value of the function declines with increasing distance from the center of the window (when dist == 0; note that the value never becomes zero!). This is a Gaussian kernel. The shape of the Gaussian kernel depends on a variance parameter, which we will call the kernel bandwidth. The bandwidth controls how rapidly the weight assigned to distant events decays. Change the value of the argument sd in the chunk above. You will see that as it becomes smaller, the slope of the kernel becomes steeper (and distant observations are downweighted rapidly). On the contrary, as it becomes larger, the slope becomes less steep (and distant events are weighted almost as highly as close events). Kernel density estimates are usually obtained by creating a fine grid that is superimposed on the region. The kernel function then visits each point on the grid and obtains an estimate of the density by summing the weights of all events as per the kernel function. Kernel density is implemented in spatstat and can be used as follows. The input is a ppp object, and optionally a sigma argument that corresponds to the bandwidth of the kernel: kernel_density &lt;- density(split(pp0.ppp), sigma = 0.1) plot(kernel_density) Compare to the distribution of events: plot(split(pp0.ppp)) The plots above illustrate how the map of the kernel density is better able to capture the variations in density across the region. In fact, kernel density is a smooth estimate of the underlying intensity of the process, and the degree of smoothing is controlled by the bandwidth. "],
["activity-5-point-pattern-analysis-ii.html", "Chapter 12 Activity 5: Point Pattern Analysis II 12.1 Practice questions 12.2 Learning objectives 12.3 Suggested reading 12.4 Preliminaries 12.5 Activity", " Chapter 12 Activity 5: Point Pattern Analysis II Remember, you can download the source file for this activity from here. 12.1 Practice questions Answer the following questions: How does the quadrat-based test of independence respond to a small number of quadrats? How does the quadrat-based test of independence respond to a large number of quadrats? What are the limitations of quadrat analysis? What is a kernel function? How does the bandwidth affect a kernel function? 12.2 Learning objectives In this activity, you will: Explore a dataset using quadrats and kernel density. Experiment with different parameters (number/size of kernels and bandwidths). Discuss the impacts of selecting different parameters. Hypothesize about the underlying spatial process based on your analysis. 12.3 Suggested reading O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 5. John Wiley &amp; Sons: New Jersey. 12.4 Preliminaries For this activity you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity. In addition to tidyverse, you will need spatstat, a package designed for the analysis of point patterns (you can learn about spatstat here and here): library(tidyverse) library(spatstat) library(geog4ga3) In the practice that preceded this activity, you learned about the concepts of intensity and density, about quadrats, and also how to create density maps. Begin by loading the data that you will use in this activity: data(&quot;bear_df&quot;) This dataset was sourced from the Scandinavia Bear Project, a Swedish-Noruegian collaboration that aims to study the ecology of brown bears, to provide decision makers with evidence to support bear management, and to provide information regarding bears to the public. You can learn more about this project here. The project involves tagging bears with GPS units, so that their movements can be tracked. The dataset includes coordinates of one bear’s movement over a period of several weeksin 2004. The dataset was originally taken from the adehabitatLT package but was somewhat simplified for this activity. Instead of full date and time information, the point pattern is marked more simply as “Day Time” and “Night Time”, to distinguish between diurnal and nocturnal activity of the bear. Summarize the contents of this dataframe: summary(bear_df) ## x y marks ## Min. :515743 Min. :6812138 Day Time :502 ## 1st Qu.:518995 1st Qu.:6813396 Night Time:498 ## Median :519526 Median :6816724 ## Mean :519321 Mean :6816474 ## 3rd Qu.:519983 3rd Qu.:6818111 ## Max. :522999 Max. :6821440 The Min. and Max. of x and y give us an idea of the region covered by this dataset. We can use these values to approximate a window for the region (as an experiment, you could try changing these values to create regions of different sizes): W &lt;- owin(xrange = c(515000, 523500), yrange = c(6812000, 6822000)) Next, we can convert the dataframe into a ppp-class object suitable for analysis using the package spatstat: bear.ppp &lt;- as.ppp(bear_df, W = W) You can check the contents of the ppp object by means of summary: summary(bear.ppp) ## Marked planar point pattern: 1000 points ## Average intensity 1.176471e-05 points per square unit ## ## Coordinates are given to 1 decimal place ## i.e. rounded to the nearest multiple of 0.1 units ## ## Multitype: ## frequency proportion intensity ## Day Time 502 0.502 5.905882e-06 ## Night Time 498 0.498 5.858824e-06 ## ## Window: rectangle = [515000, 523500] x [6812000, 6822000] units ## Window area = 8.5e+07 square units Now that you have loaded the dataframe and converted to a ppp object, you are ready for the next activity. 12.5 Activity Analyze the point pattern for the movements of the bear using quadrat and kernel density methods. Experiment with different quadrat sizes and kernel bandwidths. Explain your choice of parameters (quadrat sizes and kernel bandwidths) to a fellow student. Decide whether these patterns are random, and support your decision. Do you see differences in the activity patterns of the bear by time of day? What could explain those differences, if any? Discuss the limitations of your conclusions, and of quadrat/kernel (density-based) approaches more generally. "],
["point-pattern-analysis-iii.html", "Chapter 13 Point Pattern Analysis III 13.1 Learning Objectives 13.2 Suggested Readings 13.3 Preliminaries 13.4 Motivation 13.5 Nearest Neighbors 13.6 G-function", " Chapter 13 Point Pattern Analysis III NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. In the last practice/session your learning objectives included: The intuition behind the quadrat-based test of independence. The concept of kernel density. The limitations of density-based analysis More ways to work with ppp objects. If you wish to work interactively with this chapter you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. 13.1 Learning Objectives In this practice, you will learn: About clustered and dispersed (or regular) patterns. The concept of nearest neighbors. About distance-based methods for point pattern analysis. About the G-function for the analysis of event-to-event nearest neighbor distances. 13.2 Suggested Readings Bailey TC and Gatrell AC (1995) Interactive Spatial Data Analysis, Chapter 3. Longman: Essex. Baddeley A, Rubak E, Turner R (2016) Spatial Point Pattern: Methodology and Applications with R, Chapter 8. CRC: Boca Raton. Bivand RS, Pebesma E, Gomez-Rubio V (2008) Applied Spatial Data Analysis with R, Chapter 7. Springer: New York. Brunsdon C and Comber L (2015) An Introduction to R for Spatial Analysis and Mapping, Chapter 6, 6.1 - 6.6. Sage: Los Angeles. O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 5. John Wiley &amp; Sons: New Jersey. 13.3 Preliminaries As usual, it is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) library(spatstat) library(geog4ga3) Load the datasets that you will use for this practice: data(&quot;pp0_df&quot;) Examine the contents of this dataframe: summary(pp0_df) ## x y marks ## Min. :0.0456 Min. :0.03409 Pattern 1:36 ## 1st Qu.:0.2251 1st Qu.:0.22963 Pattern 2:36 ## Median :0.4282 Median :0.43363 ## Mean :0.4916 Mean :0.47952 ## 3rd Qu.:0.7812 3rd Qu.:0.77562 ## Max. :0.9564 Max. :0.94492 As you can see, this dataframe includes two point patterns, labeled “Pattern 1” and “Pattern 2”, and each consists of \\(n=36\\) events. The range of the coordinates suggests a window as follows: W &lt;- owin(c(0,1), c(0,1)) Given window object W, it is possible to transform the dataframe into a ppp object: pp0.ppp &lt;- as.ppp(pp0_df, W = W) 13.4 Motivation Quadrats and kernel density are examples of density-based analysis. These techniques are useful to help you understand the large scale variation of a distribution of events, but as previously discussed, may sometimes be less informative by not taking into account small scale variations in the locations of the events. For this reason, the following two patterns, despite being very different, give identical number of counts per quadrat: plot(split(pp0.ppp)) plot(quadratcount(split(pp0.ppp), nx = 3, ny = 3)) The two patterns above have similar density, However, “Pattern 1” displays clustering, a situation characterized by events generally being in close proximity to others. “Pattern 2”, on the other hand, displays dispersion or regularity, a situation where points tend to be located at fairly regular distances from each other. With some fiddling of the parameters, quadrats can be coaxed to tease out the variations in density, for instance: plot(quadratcount(split(pp0.ppp), nx = 9, ny = 9)) As a visualization technique, this gives a better sense of the variations in density. However, as noted previously, the quality of the test deteriorates when there are many quadrats with small counts. As an alternative, kernel density can be used to visualize the smoothed estimate of the density: plot(density(split(pp0.ppp), sigma = 0.075)) However, even when we can visualize the variations in density, we cannot, from the kernel estimate alone, tell if high/low values exceed those of a null landscape — in other words, we lack at the moment a way to test the hypothesis that the density is higher than what would be expected from a null landscape. In this practice you will learn about a family of techniques that instead of measuring the density, explore patterns by means of distance distributions. 13.5 Nearest Neighbors Let us begin by introducing the concept of a nearest neighbor. The nearest neighbor of a location is the event that is closest to said location given some metric. This metric is usually Euclidian distance on the plane, that is, distance as measured using a straight line between the location and the event. In principle, the metric can be selected according to the characteristics of a dataset: this could be Euclidean distance, great circle distance, or network distance, for events on networks, for instance (see Figure 13.1). Figure 13.1: Examples of distance metrics In this way, the nearest neighbor is the event j with the shortest separation from location i: \\[ \\text{Event }j\\text{ is the nearest neighbor of location }i\\text{ if: }d_{ij}\\le d_{ik} \\forall k \\] Ties are relatively rare in most realistic point patterns (even in regular patterns), and may not have a big impact on the analysis. The package spatstat includes functions to calculate Euclidean distances. Three functions are relevant: pairdist(): returns the pairwise distance between all pairs of events i and j. nndist(): returns a vector of distances from events to to their corresponding nearest neighbors; these distances are obtained by sorting the pairwise distances, and selecting the minimum value for each event. distmap(): returns a pixel image with the distance from each pixel to the nearest event; in effect this is a map of the distances between empty spaces and their corresponding nearest events. With these functions we can calculate, for instance, the following distances: pp0_nn1 &lt;- nndist(split(pp0.ppp)$&quot;Pattern 1&quot;) Let us explore the distribution of these distances by means of a histogram: ggplot() + geom_histogram(data = data.frame(dist = pp0_nn1), aes(dist), binwidth = 0.03) Notice how most events have a nearest neighbor at a relatively short distance (&lt;0.05). Compare to the distribution of distances in “Pattern 2” of pp0.ppp: pp0_nn2 &lt;- nndist(split(pp0.ppp)$&quot;Pattern 2&quot;) ggplot() + geom_histogram(data = data.frame(dist = pp0_nn2), aes(dist), binwidth = 0.03) In this case, most events have a nearest neighbot at a distance of approximately 0.15. Another useful tool is a Stienen diagram. A Steinen diagram is essentially a proportional symbol plot of the events with symbols of size proportional to the distance to their nearest neighbor. For example, for “Pattern 1” in pp0.ppp (Notice the use of %mark% to add an attribute to the ppp object; the attribute is the distance to the nearest neighbor): plot(split(pp0.ppp)$&quot;Pattern 1&quot; %mark% (pp0_nn1), markscale = 1, main = &quot;Stienen diagram&quot;) In this diagram, the largest circle is not very large: even events that are relatively isolated are not a long distance away from their nearest neighbor. This fits the definition of clustering as situation where events are close to other events. Compare to “Pattern 2”: plot(split(pp0.ppp)$&quot;Pattern 2&quot; %mark% (pp0_nn2), markscale = 1, main = &quot;Stienen diagram&quot;) Notice how all circles are very similar in size: this fits the definition of dispersion, where events are more or less equally distant from their nearest neighbors. Lets use the function runifpoint from the spatstat package to generate a null landscape: rand_ppp &lt;- runifpoint(36) If we plot the Stienen diagram for this point pattern: rand_nn &lt;- nndist(rand_ppp) plot(rand_ppp %mark% (rand_nn), markscale = 1, main = &quot;Stienen diagram&quot;) In a null landscape, the distribution of the size of the symbols would tend to be random! The concept of nearest neighbors is useful to define a family of techniques that are based on the distribution of distances to nearest neighbors. Three such techniques are introduced here. 13.6 G-function As you have seen above, the distribution of distances to nearest neighbors presents distinctive characteristics for different types of patterns. What is needed is a convenient way to summarize the distribution of distances to nearest neighbors. A way to do so is by means of a plot of the cumulative distribution function. A cumulative distribution is simply the proportion of events that are have a nearest neighbor at a distance less than some value x. When the value of x is very small, no events have a nearest neighbor at \\(d_{ij}&lt;x\\). When x is very large all events have a nearest neighbor at \\(d_{ij}&lt;x\\). The cumulative distribution thus depends on the value of x. Imagine for instance the following hypothetical distribution of distances of ten events to their nearest neighbors (the first event’s nearest neighbor is at a distance of 1, the second event’s nearest neighbor is at 2, the third’s at 0.5, and so on): nnd &lt;- c(1, 2, 0.5, 2.5, 1.7, 4, 3.5, 1.2, 2.3, 2.8) When x = 0, zero events have a nearest neighbor. When x = 1, two events have nearest neighbor at dist &lt;= 1. When x = 2, five events have a nearest neighbor at dist &lt;= 2. When x = 3, eight events have a nearest neighbor at dist &lt;= x. When x = 4, ten out of ten events have a nearest neighbor at dist &lt;= 4. We can plot these numbers of events as a proportion: df &lt;- data.frame(x = c(0, 1, 2, 3, 4), proportion = c(0, 3/10, 5/10, 8/10, 10/10)) ggplot() + geom_line(data = df, aes(x = x, y = proportion)) The cumulative distribution function of distances from event to nearest neighbor is called a G-function. This function is defined as follows, with \\(d_{ik}\\) as the distance from the event at i to its nearest neighbor: \\[ \\hat{G}(x)=\\frac{(d_{ik}\\le x, \\forall i)}{n} \\] This function (with a hat, because it is estimated from the data), can be used to explore the spatial point pattern. When doing so, it is useful to know that the theoretical value of G (assuming a null landscape generated by a Poisson distribution) is as follows: \\[ G_{pois}(x) = 1 - exp(-\\lambda \\pi x^2). \\] When the empirical \\(\\hat{G}(x)\\) is greater than the theoretical function, this suggests that the events tend to be closer than expected, compared to the null landscape. On the contrary, when the empirical function is less than the theoretical function, this would suggest a dispersed pattern. The G-function is implemented in spatstat as Gest (for G estimated): g_pattern1 &lt;- Gest(split(pp0.ppp)$&quot;Pattern 1&quot;, correction = &quot;none&quot;) (For the moment ignore the argument “correction”; we will discuss corrections later on.) The plot function can be used to visualize the estimated G (with r = x): plot(g_pattern1) In the plot above, the empirical function is the solid black line, and the theoretical is the dashed red line. If you examine these functions, you will see that about 50% of events have a nearest neighbor at a distance of less than approximately 0.04. In the null landscape, in contrast, only about 16% of events have a nearest neighbor at less than 0.04: plot(g_pattern1) lines(x = c(0.04, 0.04), y = c(-0.1, 0.5), lty = &quot;dotted&quot;) lines(x = c(-0.1, 0.04), y = c(0.5, 0.5), lty = &quot;dotted&quot;) lines(x = c(-0.1, 0.04), y = c(0.16, 0.16), lty = &quot;dotted&quot;, col = &quot;red&quot;) What this suggests is that in the actual landscape events tend to be much closer to other events in comparison the null landscape, and would therefore be suggestive of clustering. Compare to “Pattern 2”: g_pattern2 &lt;- Gest(split(pp0.ppp)$&quot;Pattern 2&quot;, correction = &quot;none&quot;) plot(g_pattern2) Now the empirical function is below the one for the null landscape. Notice too that all events have a nearest neighbor in a limited range of distances, between 0.14 and 0.18. This is indicative of a dispersed, or regular pattern. And the random pattern that you created before: g_pattern_rnd &lt;- Gest(rand_ppp, correction = &quot;none&quot;) plot(g_pattern_rnd) In this case, the empirical function more closely resembles the theoretical function for the null landscape. By considering the distribution of distances to nearest neighbors, you can generate additional information on a point pattern to complement the density-based analysis of the preceding chapters. "],
["activity-6-point-pattern-analysis-iii.html", "Chapter 14 Activity 6: Point Pattern Analysis III 14.1 Practice questions 14.2 Learning objectives 14.3 Suggested reading 14.4 Preliminaries 14.5 Activity", " Chapter 14 Activity 6: Point Pattern Analysis III Remember, you can download the source file for this activity from here. 14.1 Practice questions Answer the following questions: List and explain two limitations of quadrat analysis. What is clustering? What could explain a clustering in a set of events? What is regularity? What could explain it? Describe the concept of nearest neighbors. What is a cumulative distribution function? 14.2 Learning objectives In this activity, you will: Explore a dataset using distance-based approaches. Compare the characteristics of different types of patterns. Discuss ways to evaluate how confident you are that a pattern is random. 14.3 Suggested reading O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 5. John Wiley &amp; Sons: New Jersey. 14.4 Preliminaries For this activity you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity. In addition to tidyverse, you will need spatstat, a package designed for the analysis of point patterns (you can learn about spatstat here and here): library(tidyverse) library(spatstat) library(maptools) # Needed to convert `SpatialPolygons` into `owin` object library(sf) library(geog4ga3) In the practice that preceded this activity, you learned about the concepts of intensity and density, about quadrats, and also how to create density maps. For this practice, you will use the data that you first encountered in Activity 4, that is, the business locations in Toronto. Begin by reading the geospatial files, namely the city boundary of Toronto. You need the sf object, which will be converted into a spatstat window object: data(&quot;Toronto&quot;) Convert the sf object to an owin object (via SpatialPolygons, hence as(x, &quot;Spatial&quot;): Toronto.owin &lt;- as.owin(as(Toronto, &quot;Spatial&quot;)) # Requires `maptools` package Next the data that you will use in this activity needs to be loaded. Each dataframe is converted into a ppp object using the as.ppp function, again after extracting the coordinates of the events from the sf object: data(&quot;Fast_Food&quot;) Fast_Food.ppp &lt;- as.ppp(st_coordinates(Fast_Food), W = Toronto.owin) data(&quot;Gas_Stands&quot;) Gas_Stands.ppp &lt;- as.ppp(st_coordinates(Gas_Stands), W = Toronto.owin) data(&quot;Paez_Mart&quot;) Paez_Mart.ppp &lt;- as.ppp(st_coordinates(Paez_Mart), W = Toronto.owin) If you inspect your workspace, you will see that the following ppp objects are there: Fast_Food.ppp Gas_Stands.ppp Paez_Mart.ppp These are locations of fast food restaurants and gas stands in Toronto (data are from 2008). Paez Mart on the other hand is a project to cover Toronto with convenience stores. The points are the planned locations of the stores. You can check the contents of ppp objects by means of summary: summary(Fast_Food.ppp) ## Planar point pattern: 614 points ## Average intensity 9.681378e-07 points per square unit ## ## Coordinates are given to 1 decimal place ## i.e. rounded to the nearest multiple of 0.1 units ## ## Window: polygonal boundary ## 10 separate polygons (no holes) ## vertices area relative.area ## polygon 1 4185 630935000.0 9.95e-01 ## polygon 2 600 2536260.0 4.00e-03 ## polygon 3 193 237206.0 3.74e-04 ## polygon 4 28 26539.7 4.18e-05 ## polygon 5 52 142793.0 2.25e-04 ## polygon 6 67 158439.0 2.50e-04 ## polygon 7 41 83470.2 1.32e-04 ## polygon 8 30 42934.1 6.77e-05 ## polygon 9 36 33866.6 5.34e-05 ## polygon 10 8 11069.2 1.75e-05 ## enclosing rectangle: [609550.5, 651611.8] x [4826375, 4857439] units ## Window area = 634207000 square units ## Fraction of frame area: 0.485 Now that you have the data that you need in the right format, you are ready for the next activity. 14.5 Activity Calculate the event-to-event distances to nearest neighbors using the function nndist(). Do this for all fast food establishments (pooled) and then for each type of establishment (i.e, “Chicken”, “Hamburger”, “Pizza”, “Sub”). Create Stienen diagrams using the distance vectors obtained in Step 1. Discuss the diagrams with a fellow student. Plot the empirical G-function for all fast food establishments (pooled) and then for each type of establishment (i.e, “Chicken”, “Hamburger”, “Pizza”, “Sub”). Is there evidence of clustering/regularity? How confident are you to make a decision whether the patterns are not random? What could you do to assess your confidence in making a decision whether the patterns are random? Explain. "],
["point-pattern-analysis-iv.html", "Chapter 15 Point Pattern Analysis IV 15.1 Learning Objectives 15.2 Suggested Readings 15.3 Preliminaries 15.4 Motivation 15.5 F-function 15.6 K-function", " Chapter 15 Point Pattern Analysis IV NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. In the last practice/session your learning objectives included: Learning about clustered and dispersed (or regular) patterns. Learning the concept of nearest neighbors. Learning about distance-based methods for point pattern analysis. Learning about the G-function for the analysis of event-to-event nearest neighbor distances. If you wish to work interactively with this chapter you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. 15.1 Learning Objectives In this chapter, you will: Learn about the F- or empty space function. Consider the issue of patterns at multiple scales. Learn about the K-function. Apply both of these techniques using a simple example. 15.2 Suggested Readings Bailey TC and Gatrell AC (1995) Interactive Spatial Data Analysis, Chapter 3. Longman: Essex. Baddeley A, Rubak E, Turner R (2016) Spatial Point Pattern: Methodology and Applications with R, Chapters 7 - 8. CRC: Boca Raton. Bivand RS, Pebesma E, Gomez-Rubio V (2008) Applied Spatial Data Analysis with R, Chapter 7. Springer: New York. Brunsdon C and Comber L (2015) An Introduction to R for Spatial Analysis and Mapping, Chapter 6, 6.1 - 6.6. Sage: Los Angeles. O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 5. John Wiley &amp; Sons: New Jersey. 15.3 Preliminaries As usual, it is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) library(spatstat) library(geog4ga3) Load the datasets that you will use for this practice: data(&quot;pp1_df&quot;) data(&quot;pp2_df&quot;) data(&quot;pp3_df&quot;) data(&quot;pp4_df&quot;) data(&quot;pp5_df&quot;) These five dataframes include the coordinates of events set in the space of a unit square. To convert these dataframes into ppp objects we first define a window: W &lt;- owin(c(0, 1), c(0, 1)) And then use the function as.ppp to convert into ppp: pp1.ppp &lt;- as.ppp(pp1_df, W = W) pp2.ppp &lt;- as.ppp(pp2_df, W = W) pp3.ppp &lt;- as.ppp(pp3_df, W = W) pp4.ppp &lt;- as.ppp(pp4_df, W = W) pp5.ppp &lt;- as.ppp(pp5_df, W = W) 15.4 Motivation Distance-based approaches like the \\(\\hat{G}\\)-function provide a useful complement to density-based approached. They can be implemented in more ways than we have seen so far. In this practice, you will learn about two more tools for conducting distance-based analysis, the \\(\\hat{F}\\)-function and the \\(\\hat{K}\\)-function. 15.5 F-function The \\(\\hat{G}\\)-function was defined as the cumulative distribution of the distances from events to their nearest neighboring event. The \\(\\hat{F}\\)-function is based on the same premise, but instead of using event-to-event distances, it uses point-to-event distances. Recall that a point is an arbitrary location on a map that needs not necessarily be the location of an event. It may well be (and typically is) empty space. For this reason, the \\(\\hat{F}\\)-function is sometimes called the empty space function: the more empty space there is in a region, the longer the distances of points to the nearest neighboring event. More formally, this function is defined as follows, with \\(d_{ik}\\) as the distance from the point at i (not necessarily an event!) to its nearest neighboring event at k: \\[ \\hat{F}(x)=\\frac{(d_{ik}\\le x, \\forall i)}{n} \\] Again, we use the hat notation to indicate that the function is estimated from the data. The theoretical distribution of this function is known (based on a null landscape generated by a spatially random Poisson process), and is as follows: \\[ F_{pois}(x) = 1 - exp(-\\lambda \\pi x^2). \\] Notice that the distribution is in fact identical to that for G. This makes sense: if the distribution of events is spatially random, the distribution of empty space in the region must be random as well! The interpretation of \\(\\hat{F}(x)\\) is the opposite of \\(\\hat{G}(x)\\): When the empirical \\(\\hat{F}(x)\\) is greater than the theoretical function, this suggests that empty spaces are closer to events than expected, compared to the null landscape, as in a dispersed pattern. On the contrary, when the empirical function is less than the theoretical function, this would suggest a clustered pattern. The \\(\\hat{F}\\)-function can be implemented in at least two ways: (1) by using a fine grid to measure the distance to events; or (2) by measuring the distance to events from randomly drawn coordinates. The implementation in spatstat is the first one, which results in a pixel-based image of empty space. Let’s illustrate this with the point pattern pp1.ppp. You can verify that this is already a ppp object: class(pp1.ppp) ## [1] &quot;ppp&quot; Begin by plotting the pattern: plot(pp1.ppp) The empty space map is obtained by means of the distmap function: empty_space_map1 &lt;- distmap(pp1.ppp) The plot of this is: plot(empty_space_map1) Similar to the Stienen diagrams that you used previously, this map shows the distance from any location on the map to the nearest event: the smaller the value, the closer the point is to an event. Compare the map above to pp2.ppp: empty_space_map2 &lt;- distmap(pp2.ppp) plot(empty_space_map2) In the second point pattern, there is more open space in the region. This is also apparent from the symbols map: plot(pp2.ppp) The \\(\\hat{F}\\)-function is implemented in spatstat as Fest (for F-estimated), and it requires a ppp object as an input. Another possible input is whether a correction is to be used. This refers to boundary corrections. Since we have not yet discussed them, we will select “none”: f_pattern1 &lt;- Fest(pp1.ppp, correction = &quot;none&quot;) This function can be plotted as follows: plot(f_pattern1) Compare to the second pattern: f_pattern2 &lt;- Fest(pp2.ppp, correction = &quot;none&quot;) plot(f_pattern2) In the empirical pattern, points on a grid tend to be more distant from events than what you would expect from the null landscape: this suggests that the points are clustered. Try plotting the \\(\\hat{G}\\)-functions for these patterns, and compare. 15.6 K-function A limitation of the two techniques that you have seen so far is that they deal with a single scale: the \\(k\\)-th nearest neighbor (typically the first, although they can be used for the 2nd, 3rd, and so on nearest neighbor!). Their single scale nature means that these functions can easily miss patterns at different scales. Consider for instance the following point pattern: plot(pp3.ppp) The events above initially appear to be clustered. However, at a different scale, a second pattern becomes evident. In fact, what we observe is a regular distribution of clusters. The following pattern, on the other hand, appears to be a random distribution of regularly spaced events: plot(pp4.ppp) Whereas the last point pattern is of clusters of dispersed events that are themselves regularly spaced: plot(pp5.ppp) Both \\(\\hat{G}(x)\\) or \\(\\hat{F}(x)\\) when applied to any of these patterns will detect clustering at the scale of the first nearest neighbor. Regrettably, they fail to detect patterns that might exist at other scales. For instance: g_pattern3 &lt;- Gest(pp3.ppp, correction = &quot;none&quot;) plot(g_pattern3) A different technique, called the \\(\\hat{K}\\)-function, is designed to detect patterns at multiple scales (see Ripley 1976; and Haase 1995). The intuition behind the function is as follows. Imagine that you visit all events in the point patter in sequence. Each time you visit an event you do the following. You create a circle with radius “x” centered on the event, and then you count the number of events that are within the circle. Then you increase “x” by some distance, and repeat the process. Once that you have created the last circle (which will be suitably large to capture patterns at that scale), you move and visit the next event in the series and repeat the exact same process. These counts of events at distances “x” are aggregated and normalized by the estimated intensity of the point pattern. More formally, this is (with \\(A\\) as the area of the region): \\[ \\hat{K}(x)=\\frac{1}{\\hat{\\lambda}A}\\sum_{i}\\sum_{j\\neq i}(d_{ij}\\le x). \\] As before, the theoretical values for this function are known for the case of a null landscape generated by a Poisson process: \\[ K_{pois}(x)=\\pi x^2. \\] When the empirical function is greater than the theoretical function, this would suggest that events are typically surrounded by more events at that distance than what the null landscape would have. This is interpreted as evidence of clustering. In contrast, when the empirical function is less than the theoretical one, this would suggest that events are typically surrounded by fewer events at that distance than what would be expected from a null landscape. This is interpreted as dispersion. The \\(\\hat{K}\\)-function is implemented in the package spatstat as Kest. Lets plot again pp3: plot(pp3.ppp) Next, lets calculate and plot the \\(\\hat{K}\\)-function: k_pattern3 &lt;- Kest(pp3.ppp, correction = &quot;none&quot;) plot(k_pattern3) As seen from the plot, the function is suggestive of clustering at smaller scales, but regularity at a larger scale. Try this now with the last pattern: plot(pp5.ppp) If you calculate and plot the \\(\\hat{K}\\)-function: k_pattern5 &lt;- Kest(pp5.ppp, correction = &quot;none&quot;) plot(k_pattern5) You will see that the plot correctly suggests dispersion at the very small scale, followed by clustering at an intermediate scale. There are indeed clusters of nine events surrounded by empty space, before other clusters of regular events are detected at the largest scale, following a regular pattern. Of the distance-based techniques that you have seen so far, \\(\\hat{G}(x)\\) and \\(\\hat{F}(x)\\) are often used as complements. The \\(\\hat{K}(x)\\) is useful when exploring multi-scale patterns. This concludes the chapter, and our coverage of distance-based techniques. References "],
["activity-7-point-pattern-analysis-iv.html", "Chapter 16 Activity 7: Point Pattern Analysis IV 16.1 Practice questions 16.2 Learning objectives 16.3 Suggested reading 16.4 Preliminaries 16.5 Activity", " Chapter 16 Activity 7: Point Pattern Analysis IV Remember, you can download the source file for this activity from here. 16.1 Practice questions Answer the following questions: What does the \\(\\hat{G}\\)-function measure? What does the \\(\\hat{F}\\)-function measure? How do these two functions relate to one another? Describe the intution behind the \\(\\hat{K}\\)-function. How does the \\(\\hat{K}\\)-function capture patterns at multiple scales? 16.2 Learning objectives In this activity, you will: Explore a dataset using single scale distance-based techniques. Explore the characteristics of a point pattern at multiple scales. Discuss ways to evaluate how confident you are that a pattern is random. 16.3 Suggested reading O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 5. John Wiley &amp; Sons: New Jersey. 16.4 Preliminaries For this activity you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity. In addition to tidyverse, you will need spatstat, a package designed for the analysis of point patterns (you can learn about spatstat here and here): library(tidyverse) library(spatstat) library(maptools) # Needed to convert `SpatialPolygons` into `owin`-class object library(sf) library(geog4ga3) For this activity, you will use the datasets that you used in Activity 6, including the geospatial files for Toronto’s city boundary: data(&quot;Toronto&quot;) Convert the sf object to an owin object (via SpatialPolygons, hence as(x, &quot;Spatial&quot;): Toronto.owin &lt;- as.owin(as(Toronto, &quot;Spatial&quot;)) # Requires `maptools` package Next, load the data that you will use in this activity. Each dataframe is converted into a ppp object using the as.ppp function, again after extracting the coordinates of the events from the sf object: data(&quot;Fast_Food&quot;) Fast_Food.ppp &lt;- as.ppp(st_coordinates(Fast_Food), W = Toronto.owin) data(&quot;Gas_Stands&quot;) Gas_Stands.ppp &lt;- as.ppp(st_coordinates(Gas_Stands), W = Toronto.owin) data(&quot;Paez_Mart&quot;) Paez_Mart.ppp &lt;- as.ppp(st_coordinates(Paez_Mart), W = Toronto.owin) Now that you have the datasets in the appropriate format, you are ready for the next activity. 16.5 Activity Plot the empirical F-function for all fast food establishments (pooled) and then for each type of establishment (i.e, “Chicken”, “Hamburger”, “Pizza”, “Sub”). Discuss your results with a fellow student. Is there evidence of clustering/regularity? Plot the empirical K-function for all fast food establishments (pooled) and then for each type of establishment (i.e, “Chicken”, “Hamburger”, “Pizza”, “Sub”). What can you say about patterns at multiple-scales based on point 4 above? How confident are you to make a decision whether the patterns are not random? What could you do to assess your confidence in making a decision whether the patterns are random? Explain. "],
["point-pattern-analysis-v.html", "Chapter 17 Point Pattern Analysis V 17.1 Learning Objectives 17.2 Suggested Readings 17.3 Preliminaries 17.4 Motivation: Hypothesis Testing 17.5 Null Landscapes Revisited 17.6 Simulation Envelopes 17.7 Things to Keep in Mind!", " Chapter 17 Point Pattern Analysis V NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. In the last practice/session your learning objectives included: Learning about the \\(\\hat{F}\\)- or empty space function. Considering the issue of patterns at multiple scales. Learning about the \\(\\hat{K}\\)-function. Applying these techniques using a simple example. Please review the previous practices if you need a refresher on these concepts. If you wish to work interactively with this chapter you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. 17.1 Learning Objectives In this chapter, you will: Revisit the concept of hypothesis testing Revisit the concept of null landscapes. Learn about the use of simulation for hypothesis testing. Learn to implement simulation envelopes Consider some caveats when working with point patterns 17.2 Suggested Readings Bailey TC and Gatrell AC (1995) Interactive Spatial Data Analysis, Chapter 3. Longman: Essex. Baddeley A, Rubak E, Turner R (2016) Spatial Point Pattern: Methodology and Applications with R, Chapter 10. CRC: Boca Raton. Bivand RS, Pebesma E, Gomez-Rubio V (2008) Applied Spatial Data Analysis with R, Chapter 7. Springer: New York. Brunsdon C and Comber L (2015) An Introduction to R for Spatial Analysis and Mapping, Chapter 6, 6.1 - 6.6. Sage: Los Angeles. O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 5. John Wiley &amp; Sons: New Jersey. 17.3 Preliminaries As usual, it is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) library(spatstat) library(geog4ga3) Load the datasets that you will use for this practice: data(&quot;pp1_df&quot;) data(&quot;pp2_df&quot;) data(&quot;pp3_df&quot;) data(&quot;pp4_df&quot;) data(&quot;pp5_df&quot;) These five dataframes include the coordinates of events set in the space of a unit square. To convert these dataframes into ppp objects we first define a window: W &lt;- owin(c(0, 1), c(0, 1)) And then use the function as.ppp to convert into ppp: pp1.ppp &lt;- as.ppp(pp1_df, W = W) pp2.ppp &lt;- as.ppp(pp2_df, W = W) pp3.ppp &lt;- as.ppp(pp3_df, W = W) pp4.ppp &lt;- as.ppp(pp4_df, W = W) pp5.ppp &lt;- as.ppp(pp5_df, W = W) 17.4 Motivation: Hypothesis Testing In the previous sessions you learned about density- and distance-based techniques for the analysis of spatial point patterns. With the exception of the test of independence for quadrats, other techniques (including kernel density, the \\(\\hat{G}\\)- and \\(\\hat{F}\\)-functions, and the \\(\\hat{K}\\)-function), did not have a formal hypothesis testing framework. The question of “how confident are you when deciding whether a pattern is random” forms the basis of hypothesis testing. In other words, when making a decision whether the reject a null hypothesis, we would like to know what is the probability that we are making a mistake when doing so. Quantifying our uncertainty is a key feature of statistical analysis. In statistics, tests of hypothesis are developed following these general steps: Identify a null hypothesis of interest, and if possible alternative hypotheses as well (although the latter is not always possible). For instance, in point pattern analysis, a null hypothesis of interest is whether a pattern is random. If it is not, we would like to know in which way it is not random (i.e., is it clustered? Or on the contrary, is it regular?) Derive the expected value of the summary statistic of interest. It the case of the \\(\\hat{G}\\)-function, for instance, the expected value of the function under the null hypothesis of a spatially random Poisson process is: \\[ G_{pois}(x) = 1 - exp(-\\lambda \\pi x^2). \\] Similar expressions were presented for the \\(\\hat{F}\\)-function and \\(\\hat{K}\\)-function, but not for kernel density estimates. When the expected value of the function is known, the closer the empirical function is to its expected value, the more likely it is that the null hypothesis is true. For instance, the \\(\\hat{G}\\)-function of the pattern in pp1.ppp is shown below. It is quite close to the theoretical function, so the pattern is probably random. The question is, how probable is this? g_pp1 &lt;- Gest(pp1.ppp, correction = &quot;none&quot;) plot(g_pp1) To make a decision whether to reject the null hypothesis (or contrariwise, fail to reject it), we need to know how close is close to the expected value. This step depends on how much variability there is of the random process around its expected value. In other words, we need to know the variance of the expected value under the null hypothesis. Unfortunately, the variance of the theoretical random processes is not known in the case of many spatial point pattern techniques (the quadrat-based test of independence is an exception.) For a long time, this meant that the techniques remained purely descriptive, and it was not possible to quantify uncertainty when trying to decide whether a pattern was random: the decision would remain purely subjective. Fortunately, with the growth in use of computers in statistical analysis, the lack of theoretical expressions for the variance can be circumvented by means of simulation. Simulation has many applications in statistics, and is particularly relevant in the analysis of point patterns, allowing us to generate null landscapes with ease. 17.5 Null Landscapes Revisited A null landscape is a landscape produced by a random process. In previous practices you saw various different ways of generating null landscapes. A useful way of generating null landscapes for point patterns is by means of a Poisson process. The package spatstat implements this by means of the function rpoisp. This function generates a null landscape given an intensity parameter and a window. Before creating a null landscape, we can check the characteristics of the patterns in the dataset: summary(pp1.ppp) ## Planar point pattern: 81 points ## Average intensity 81 points per square unit ## ## Coordinates are given to 8 decimal places ## ## Window: rectangle = [0, 1] x [0, 1] units ## Window area = 1 square unit You can verify that the intensity in every case is 81 points per square unit, and the window is a square unit. Lets copy the window from one of the patterns in the sample dataset: W &lt;- pp1.ppp$window You can now generate a null landscape as follows: sim1 &lt;- rpoispp(lambda = 81, win = W) The value (i.e., output) of this function is a ppp object that can be analyzed in all the ways that you already know. For instance, you can plot it: plot(sim1) Importantly, you can apply any of the techniques that you have seen so far, for instance, the \\(\\hat{G}\\)-function: g_sim1 &lt;- Gest(sim1, correction = &quot;none&quot;) Lets plot the empirical functions (notice that the result of Gest is a dataframe with the values of r, the distance variable, the raw or empirical function, and the theoretical function). To plot using ggplot2 you can stack the two dataframes as follows (after adding a factor to indicate if it is the empirical function or a simulation): g_all &lt;- transmute(g_pp1, G = raw, x = r, Type = factor(&quot;Empirical&quot;)) g_all &lt;- rbind(g_all, transmute(g_sim1, G = raw, x = r, Type = factor(&quot;Simulation&quot;))) Create a plot: ggplot(data = g_all, aes(x= x, y = G, color = Type)) + geom_line() After seeing the plot above, we notice that the empirical function is very, very similar to the simulated null landscape. But is this purely a coincidence? After all, when we simulate a null landscape, there is the possibility, however improbable, that it will replicate some meaningful process purely by chance. To be sure, we can simulate and analyze a second null landscape: sim2 &lt;- rpoispp(lambda = 81, win = W) g_sim2 &lt;- Gest(sim2, correction = &quot;none&quot;) g_all &lt;- rbind(g_all, transmute(g_sim2, G = raw, x = r, Type = factor(&quot;Simulation&quot;))) Plot again: ggplot(data = g_all, aes(x= x, y = G, color = Type)) + geom_line() The empirical function continues to look very similar to the simulated null landscapes. We could simulate more null landscapes and increase our confidence that the empirical function indeed is similar to a null landscape (notice the use of a for loop to repeat the same instructions multiple times): for(i in 3:99){ g_sim &lt;- Gest(rpoispp(lambda = 81, win = W), correction = &quot;none&quot;) g_all &lt;- rbind(g_all, transmute(g_sim, G = raw, x = r, Type = factor(&quot;Simulation&quot;))) } With this you have generated 99 distinct null landscapes. Try plotting the empirical function with the functions of all your simulated landscapes: ggplot(data = g_all, aes(x= x, y = G, color = Type)) + geom_line() You can see in the plot above that the empirical function is actually not visible! It falls somewhere within the limits of the functions for the simulated patterns. The interpretation of this is as follows: out of 100 patterns (the empirical pattern and 99 null landscapes), the empirical pattern is not noticeably different from the random ones. How confident would you be rejecting the null hypothesis, i.e., deciding that the empirical pattern is not random? Let’s compare now the second pattern pp2.ppp to the simulated null landscapes: g_pp2 &lt;- Gest(pp2.ppp, correction = &quot;none&quot;) g_pp2 &lt;- transmute(g_pp2, G = raw, x = r, Type = factor(&quot;Empirical&quot;)) g_all[1:513,] &lt;- g_pp2 ggplot(data = g_all, aes(x= x, y = G, color = Type)) + geom_line() Now the empirical function is quite distinct from the null landscapes! How confident would you be rejecting the null hypothesis now? 17.6 Simulation Envelopes Simulation, as seen above, can be quite powerful for hypothesis testing in situations where the theoretical variance is not know. Essentially, the area covered by the \\(\\hat{G}\\)-functions of the simulated landscapes above are an estimate of the variance. The set of functions estimated on the null landscapes are called simulation envelopes. Since we lack a theoretical expression for the variance, we cannot obtain “p-values” to inform our decision to reject the null hypothesis. The simulation, however, provides a pseudo-p-value. If you generate 99 null landscapes, and the empirical pattern is still different, the probability that you are mistaken by rejecting the null hypothesis is at most 1% (since the next simulated landscape could expand the envelopes in such a way that it completely contains the empirical function). As you saw above, using simulation for hypothesis testing is, in general terms, a relatively straightforward process (assuming that the null process is properly defined, etc.) The package spatstat includes a function, called envelope, that can be used to generate simulation envelopes for several statistics used in point pattern analysis. For instance, for the \\(\\hat{G}\\)-function, with 99 simulated landscapes: env_pp1 &lt;- envelope(pp1.ppp, Gest, nsim = 99, funargs = list(correction = &quot;none&quot;)) ## Generating 99 simulations of CSR ... ## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, ## 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, ## 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99. ## ## Done. The envelopes can be plotted: plot(env_pp1) It is easy to see that in this case the empirical function falls within the simulation envelopes, and thus it is very unlikely to be different from the null landscapes. Also, the \\(\\hat{F}\\)-function: env_pp2 &lt;- envelope(pp2.ppp, Fest, nsim = 99, funargs = list(correction = &quot;none&quot;)) ## Generating 99 simulations of CSR ... ## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, ## 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, ## 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99. ## ## Done. plot(env_pp2) Now the empirical function lies outside of the simulation envelopes, which makes it very unlikely that it is similar to the null landscapes. And finally, the \\(\\hat{K}\\)-function: env_pp3 &lt;- envelope(pp3.ppp, Kest, nsim = 99, funargs = list(correction = &quot;none&quot;)) ## Generating 99 simulations of CSR ... ## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, ## 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, ## 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99. ## ## Done. plot(env_pp3) Again, the empirical function lies mostly outside of the simulation envelopes, meaning that it is very improbable that it represents a random process. Simulation envelopes are a powerful way to test the hypothesis of null landscapes in the case of spatial point patterns. 17.7 Things to Keep in Mind! Before concluding the topic of point pattern analysis, here are a few caveats to keep in mind. 17.7.1 Definition of a Region When defining the region (or window) for the analysis, care must be taken that it is reasonable from the perspective of the process under analysis. Defining the region in an inappropriate way can easily lead to misleading results. Consider for instance the first pattern in the dataset. This pattern was defined for a unit-square window. Lets apply the K-function to it: k_env_pp1 &lt;- envelope(pp1.ppp, Kest, nsim = 99, funargs = list(correction = &quot;none&quot;)) ## Generating 99 simulations of CSR ... ## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, ## 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, ## 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99. ## ## Done. plot(k_env_pp1) Based on this we would most likely conclude that the pattern is random. Lets now replace the unit-square window by a much larger window: W2 &lt;- owin(x = c(-2,4), y = c(-2, 4)) pp1_reg2 &lt;- as.ppp(as.data.frame(pp1.ppp), W = W2) plot(pp1_reg2) In the context of the larger window, the point pattern now looks clustered! See how the definition of the window would change your conclusions regarding the pattern: k_env_pp1_reg2 &lt;- envelope(pp1_reg2, Kest, nsim = 99, funargs = list(correction = &quot;none&quot;)) ## Generating 99 simulations of CSR ... ## 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, ## 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, ## 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99. ## ## Done. plot(k_env_pp1_reg2) 17.7.2 Edge Effects As discussed above, definition of the window (region) is critical. If at all possible, the region should be selected in such a way that it is consistent with the underlying process. This is not always possible, either because the underlying process is not known, or because of limitations in data collection capabilities. When this is the case, it is necessary to define a boundary that does not correspond necessarily with the extent of the process of interest. For example, analysis of business locations in Toronto may be limited to the city limits. This does not mean that establishments do not exist beyond those boundaries. When the extent of the process exceeds the window used in the analysis, the point pattern is observed only partially, and it is possible that the information of the location of events beyond the boundary may introduce some bias. Consider the situation illustrated in Figure 17.1. Figure 17.1: Edge effects In the figure, the region is the rectangular window. Events are observed only inside the window, but events still exist beyond the edges of the window. It is straightforward to see how the empty space (\\(\\hat{F}\\)-) function would be biased, since locations near the edge would appear the be more distant from an event than they actually are. Several corrections are available in spatstat to deal with the possibility of edge effects. So far, we have used the argument correction = &quot;none&quot; when applying the functions. The following alternative corrections are implemented: “none”, “rs”, “km”, “cs” and “best”. Alternatively correction = &quot;all&quot; selects all options. These corrections are variations of weighting schemes. In other words, the statistic is weighted to give an unbiased estimator. See: plot(Gest(pp2.ppp, correction = &quot;all&quot;)) The different corrections are plotted. It can be seen in this cases that the corrections are relatively small; however, this is not always the case. 17.7.3 Sampled Point Patterns Whereas edge effects can introduce bias by censoring the observations outside of the window/region, another issue emerges when not all events are observed inside the window. We have assumed so far that any point pattern under analysis consists of a census of events, or in other words, that all relevant events have been recorded. A sampled point pattern, on the other hand, is a pattern where not all events have been recorded (see Figure 17.2). Figure 17.2: Sampled point pattern The bias introduced by sampled point patterns can be extremely serious, because the findings depend heavily of the observations that were recorded as well as those that were not recorded! Clustered events could easily give the impression of a dispersed pattern, depending on what was observed. Imagine for instance that the events are nests of birds. If the birds tend to nest in the thickest parts of the forest that observers cannot easily access, the “observed” pattern will depend crucially on the trails and other routes of access that the researcher can use. There are no good solutions to bias introduced by sampled point patterns, and it is not recommended to use the techniques discussed here with sampled point patterns. This concludes the topic of spatial point patterns. "],
["activity-8-point-pattern-analysis-v.html", "Chapter 18 Activity 8: Point Pattern Analysis V 18.1 Practice questions 18.2 Learning objectives 18.3 Suggested reading 18.4 Preliminaries 18.5 Activity", " Chapter 18 Activity 8: Point Pattern Analysis V Remember, you can download the source file for this activity from here. 18.1 Practice questions Answer the following questions: Describe the process to use simulation for hypothesis testing Why is the selection of an appropriate region critical for the analysis of point patterns? Discuss the issues associated with the edges of a region. What is a sampled point pattern? 18.2 Learning objectives In this activity, you will: Explore a dataset using single scale distance-based techniques. Explore the characteristics of a point pattern at multiple scales. Discuss ways to evaluate how confident you are that a pattern is random. 18.3 Suggested reading O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 5. John Wiley &amp; Sons: New Jersey. 18.4 Preliminaries For this activity you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity. In addition to tidyverse, you will need spatstat, a package designed for the analysis of point patterns (you can learn about spatstat here and here): library(tidyverse) library(spatstat) library(geog4ga3) Load a dataset of your choice. It could be one of the datasets that we have used before (Toronto Business Points, Bear GPS Locations), or one of the datasets included with the package spatstat. To see what datasets are available through the package, do the following: vcdExtra::datasets(&quot;spatstat.data&quot;) ## Item class dim ## 1 Kovesi list 41x13 ## 2 amacrine ppp 6 ## 3 anemones ppp 6 ## 4 ants ppp 6 ## 5 ants.extra list 7 ## 6 austates list 4 ## 7 bdspots list 3 ## 8 bei ppp 5 ## 9 bei.extra list 2 ## 10 betacells ppp 6 ## 11 bramblecanes ppp 6 ## 12 bronzefilter ppp 6 ## 13 cells ppp 5 ## 14 cetaceans list 9x4 ## 15 cetaceans.extra list 1 ## 16 chicago ppx 3 ## 17 chorley ppp 6 ## 18 chorley.extra list 2 ## 19 clmfires ppp 6 ## 20 clmfires.extra list 2 ## 21 copper list 7 ## 22 demohyper list 3x3 ## 23 demopat ppp 6 ## 24 dendrite ppx 3 ## 25 finpines ppp 6 ## 26 flu list 41x4 ## 27 ganglia ppp 6 ## 28 gordon ppp 5 ## 29 gorillas ppp 6 ## 30 gorillas.extra list 7 ## 31 hamster ppp 6 ## 32 heather list 3 ## 33 humberside ppp 6 ## 34 humberside.convex ppp 6 ## 35 hyytiala ppp 6 ## 36 japanesepines ppp 5 ## 37 lansing ppp 6 ## 38 letterR owin 5 ## 39 longleaf ppp 6 ## 40 mucosa ppp 6 ## 41 mucosa.subwin owin 4 ## 42 murchison list 3 ## 43 nbfires ppp 6 ## 44 nbfires.extra list 2 ## 45 nbw.rect owin 4 ## 46 nbw.seg list 5 ## 47 nztrees ppp 5 ## 48 osteo list 40x5 ## 49 paracou ppp 6 ## 50 ponderosa ppp 5 ## 51 ponderosa.extra list 2 ## 52 pyramidal list 31x2 ## 53 redwood ppp 5 ## 54 redwood3 ppp 5 ## 55 redwoodfull ppp 5 ## 56 redwoodfull.extra list 5 ## 57 residualspaper list 7 ## 58 shapley ppp 6 ## 59 shapley.extra list 3 ## 60 simba list 10x2 ## 61 simdat ppp 5 ## 62 simplenet list 10 ## 63 spiders ppx 3 ## 64 sporophores ppp 6 ## 65 spruces ppp 6 ## 66 swedishpines ppp 5 ## 67 urkiola ppp 6 ## 68 vesicles ppp 5 ## 69 vesicles.extra list 4 ## 70 waka ppp 6 ## 71 waterstriders list 3 ## Title ## 1 Colour Sequences with Uniform Perceptual Contrast ## 2 Hughes&#39; Amacrine Cell Data ## 3 Beadlet Anemones Data ## 4 Harkness-Isham ants&#39; nests data ## 5 Harkness-Isham ants&#39; nests data ## 6 Australian States and Mainland Territories ## 7 Breakdown Spots in Microelectronic Materials ## 8 Tropical rain forest trees ## 9 Tropical rain forest trees ## 10 Beta Ganglion Cells in Cat Retina ## 11 Hutchings&#39; Bramble Canes data ## 12 Bronze gradient filter data ## 13 Biological Cells Point Pattern ## 14 Point patterns of whale and dolphin sightings. ## 15 Point patterns of whale and dolphin sightings. ## 16 Chicago Crime Data ## 17 Chorley-Ribble Cancer Data ## 18 Chorley-Ribble Cancer Data ## 19 Castilla-La Mancha Forest Fires ## 20 Castilla-La Mancha Forest Fires ## 21 Berman-Huntington points and lines data ## 22 Demonstration Example of Hyperframe of Spatial Data ## 23 Artificial Data Point Pattern ## 24 Dendritic Spines Data ## 25 Pine saplings in Finland. ## 26 Influenza Virus Proteins ## 27 Beta Ganglion Cells in Cat Retina, Old Version ## 28 People in Gordon Square ## 29 Gorilla Nesting Sites ## 30 Gorilla Nesting Sites ## 31 Aherne&#39;s hamster tumour data ## 32 Diggle&#39;s Heather Data ## 33 Humberside Data on Childhood Leukaemia and Lymphoma ## 34 Humberside Data on Childhood Leukaemia and Lymphoma ## 35 Scots pines and other trees at Hyytiala ## 36 Japanese Pines Point Pattern ## 37 Lansing Woods Point Pattern ## 38 Window in Shape of Letter R ## 39 Longleaf Pines Point Pattern ## 40 Cells in Gastric Mucosa ## 41 Cells in Gastric Mucosa ## 42 Murchison gold deposits ## 43 Point Patterns of New Brunswick Forest Fires ## 44 Point Patterns of New Brunswick Forest Fires ## 45 Point Patterns of New Brunswick Forest Fires ## 46 Point Patterns of New Brunswick Forest Fires ## 47 New Zealand Trees Point Pattern ## 48 Osteocyte Lacunae Data: Replicated Three-Dimensional Point Patterns ## 49 Kimboto trees at Paracou, French Guiana ## 50 Ponderosa Pine Tree Point Pattern ## 51 Ponderosa Pine Tree Point Pattern ## 52 Pyramidal Neurons in Cingulate Cortex ## 53 California Redwoods Point Pattern (Ripley&#39;s Subset) ## 54 California Redwoods Point Pattern (Ripley&#39;s Subset) ## 55 California Redwoods Point Pattern (Entire Dataset) ## 56 California Redwoods Point Pattern (Entire Dataset) ## 57 Data and Code From JRSS Discussion Paper on Residuals ## 58 Galaxies in the Shapley Supercluster ## 59 Galaxies in the Shapley Supercluster ## 60 Simulated data from a two-group experiment with replication within each group. ## 61 Simulated Point Pattern ## 62 Simple Example of Linear Network ## 63 Spider Webs on Mortar Lines of a Brick Wall ## 64 Sporophores Data ## 65 Spruces Point Pattern ## 66 Swedish Pines Point Pattern ## 67 Urkiola Woods Point Pattern ## 68 Vesicles Data ## 69 Vesicles Data ## 70 Trees in Waka national park ## 71 Waterstriders data. Three independent replications of a point pattern formed by insects. Load a dataset of your choice. You can do this by using the load() function if the dataset is in your drive (e.g., the GPS coordinates of the bear). On the other hand, if the dataset is included with the spatstat package you can do the following, for example to load the gorillas dataset: gorillas.ppp &lt;- gorillas As usual, you can check the object by means of the summary function: summary(gorillas.ppp) ## Marked planar point pattern: 647 points ## Average intensity 3.255566e-05 points per square metre ## ## *Pattern contains duplicated points* ## ## Coordinates are given to 2 decimal places ## i.e. rounded to the nearest multiple of 0.01 metres ## ## Mark variables: group, season, date ## Summary: ## group season date ## major:350 dry :275 Min. :2006-01-06 ## minor:297 rainy:372 1st Qu.:2007-03-15 ## Median :2008-02-05 ## Mean :2007-12-14 ## 3rd Qu.:2008-09-23 ## Max. :2009-05-31 ## ## Window: polygonal boundary ## single connected closed polygon with 21 vertices ## enclosing rectangle: [580457.9, 585934] x [674172.8, 678739.2] metres ## Window area = 19873700 square metres ## Unit of length: 1 metre ## Fraction of frame area: 0.795 18.5 Activity Partner with a fellow student to analyze the chosen dataset. Discuss whether the pattern is random, and how confident you are in your decision. The analysis of the pattern is meant to provide insights about the underlying process. Describe a hypothetical process that is consistent with your observations about the pattern. How would you go about further investigating the process? Discuss the limitations of the analysis, for instance, choice of modeling parameters (size of region, kernel bandwidths, edge effects, etc.) "],
["area-data-i.html", "Chapter 19 Area Data I 19.1 Learning Objectives 19.2 Suggested Readings 19.3 Preliminaries 19.4 Area Data 19.5 Processes and Area Data 19.6 Visualizing Area Data: Choropleth Maps 19.7 Visualizing Area Data: Cartograms", " Chapter 19 Area Data I NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. In last few practices/sessions, you learned about spatial point patterns. The next few sessions will concentrate on area data. If you wish to work interactively with this chapter you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. 19.1 Learning Objectives In this practice, you will learn: A formal definition of area data. Processes and area data. Visualizing area data: Choropleth maps. Visualizing area data: Cartograms. 19.2 Suggested Readings Bailey TC and Gatrell AC (1995) Interactive Spatial Data Analysis, Chapter 7. Longman: Essex. Bivand RS, Pebesma E, and Gomez-Rubio V (2008) Applied Spatial Data Analysis with R, Chapter 9. Springer: New York. Brunsdon C and Comber L (2015) An Introduction to R for Spatial Analysis and Mapping, Chapter 7. Sage: Los Angeles. O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 7. John Wiley &amp; Sons: New Jersey. 19.3 Preliminaries As usual, it is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) library(sf) library(plotly) library(cartogram) library(gridExtra) library(geog4ga3) Read the data used in this chapter. data(&quot;Hamilton_CT&quot;) The data are an object of class sf that includes the spatial information for the census tracts in the Hamilton Census Metropolitan Area in Canada and a series of demographic variables from the 2011 Census of Canada. You can quickly verify the contents of the dataframe by means of summary: summary(Hamilton_CT) ## ID AREA TRACT POPULATION ## Min. : 919807 Min. : 0.3154 Length:188 Min. : 5 ## 1st Qu.: 927964 1st Qu.: 0.8552 Class :character 1st Qu.: 2639 ## Median : 948130 Median : 1.4157 Mode :character Median : 3595 ## Mean : 948710 Mean : 7.4578 Mean : 3835 ## 3rd Qu.: 959722 3rd Qu.: 2.7775 3rd Qu.: 4692 ## Max. :1115750 Max. :138.4466 Max. :11675 ## POP_DENSITY AGE_LESS_20 AGE_20_TO_24 AGE_25_TO_29 ## Min. : 2.591 Min. : 0.0 Min. : 0.0 Min. : 0.0 ## 1st Qu.: 1438.007 1st Qu.: 528.8 1st Qu.:168.8 1st Qu.:135.0 ## Median : 2689.737 Median : 750.0 Median :225.0 Median :215.0 ## Mean : 2853.078 Mean : 899.3 Mean :253.9 Mean :232.8 ## 3rd Qu.: 3783.889 3rd Qu.:1110.0 3rd Qu.:311.2 3rd Qu.:296.2 ## Max. :14234.286 Max. :3285.0 Max. :835.0 Max. :915.0 ## AGE_30_TO_34 AGE_35_TO_39 AGE_40_TO_44 AGE_45_TO_49 ## Min. : 0.0 Min. : 0.0 Min. : 0.0 Min. : 0.0 ## 1st Qu.: 135.0 1st Qu.: 145.0 1st Qu.: 170.0 1st Qu.:203.8 ## Median : 195.0 Median : 200.0 Median : 230.0 Median :282.5 ## Mean : 228.2 Mean : 239.6 Mean : 268.7 Mean :310.6 ## 3rd Qu.: 281.2 3rd Qu.: 280.0 3rd Qu.: 325.0 3rd Qu.:385.0 ## Max. :1320.0 Max. :1200.0 Max. :1105.0 Max. :880.0 ## AGE_50_TO_54 AGE_55_TO_59 AGE_60_TO_64 AGE_65_TO_69 ## Min. : 0.0 Min. : 0.0 Min. : 0 Min. : 0.0 ## 1st Qu.:203.8 1st Qu.:175.0 1st Qu.:140 1st Qu.:115.0 ## Median :280.0 Median :240.0 Median :220 Median :157.5 ## Mean :300.3 Mean :257.7 Mean :229 Mean :174.2 ## 3rd Qu.:375.0 3rd Qu.:325.0 3rd Qu.:295 3rd Qu.:221.2 ## Max. :740.0 Max. :625.0 Max. :540 Max. :625.0 ## AGE_70_TO_74 AGE_75_TO_79 AGE_80_TO_84 AGE_MORE_85 ## Min. : 0.0 Min. : 0.00 Min. : 0.00 Min. : 0.00 ## 1st Qu.: 90.0 1st Qu.: 68.75 1st Qu.: 50.00 1st Qu.: 35.00 ## Median :130.0 Median :100.00 Median : 77.50 Median : 70.00 ## Mean :139.7 Mean :118.32 Mean : 95.05 Mean : 87.71 ## 3rd Qu.:180.0 3rd Qu.:160.00 3rd Qu.:120.00 3rd Qu.:105.00 ## Max. :540.0 Max. :575.00 Max. :420.00 Max. :400.00 ## geometry ## POLYGON :188 ## epsg:26917 : 0 ## +proj=utm ...: 0 ## ## ## 19.4 Area Data Every phenomena can be measured at a location (ask yourself, what exists outside of space?). In point pattern analysis, the unit of support is the point, and the source of randomness is the location itself. Many other forms of data are also collected at points. For instance, when the census collects information on population, at its most basic, the information can be georeferenced to an address, that is, a point. In numerous applications, however, data are not reported at their fundamental unit of support, but rather are aggregated to some other geometry, for instance an area. This is done for several reasons, including the privacy and confidentiality of the data. Instead of reporting individual-level information, the information is reported for zoning systems that often are devised without consideration to any underlying social, natural, or economic processes. Census data, for instance, is reported at different levels of geography. In Canada, the smallest publicly available geography is called a Dissemination Area or DA. A DA in Canada contains a population between 400 and 700 persons. Thus, instead of reporting that one person (or more) are located at a point (i.e., an address), the census reports the population for the DA. Other data are aggregated in similar ways (income, residential status, etc.) At the highest level of aggregation, national level statistics are reported, for instance Gross Domestic Product, or GDP. Economic production is not evenly distributed across space; however, the national GDP does not distinguish regional variations in this process. Ideally, a data analyst would work with data in its most fundamental support. This is not alway possible, and therefore many techniques have been developed to work with data that have been agregated to zones. When working with areas, it is less practical to identify the area with the coordinates (as we did with points). After all, areas will be composed of lines and reporting all the relevant coordinates is impractical. Sometimes the geometric centroids of the areas are used instead. More commonly, areas are assigned an index or unique identifier, so that a region will typically consist of a set of \\(n\\) areas as follows: \\[ R = A_1 \\cup A_2 \\cup A_3 \\cup ...\\cup A_n. \\] The above is read as “the Region R is the union of Areas 1 to n”. Regions can have a set of \\(k\\) attributes or variables associated with them, for instance: \\[ \\textbf{X}_i=[x_{i1}, x_{i2}, x_{i3},...,x_{ik}] \\] These attributes will typically be counts (e.g., number of people in a DA), or some summary measure of the underlying data (e.g., mean commute time). 19.5 Processes and Area Data Imagine that data on income by household were collected as follows: df &lt;- data.frame(x = c(0.3, 0.4, 0.5, 0.6, 0.7), y = c(0.1, 0.4, 0.2, 0.5, 0.3), Income = c(30000, 30000, 100000, 100000, 100000)) Households are geocoded as points with coordinates x and y, whereas income is in dollars. Plot the income as points (hover over the points to see the attributes): p &lt;- ggplot(data = df, aes(x = x, y = y, color = Income)) + geom_point(shape = 17, size = 5) + coord_fixed() ggplotly(p) The underlying process is one of income sorting, with lower incomes to the west, and higher incomes to the east. This could be due to a geographical feature of the landscape (for instance, an escarpment), or the distribution of the housing stock (with a neighborhood that has more expensive houses). These are examples of a variable that responds to a common environmental factor. As an alternative, people may display a preference towards being near others that are similar to them (this is called homophily). When this happens, the variable responds to itself in space. The quality of similarity or disimilarity between neighboring observations of the same variable in space is called spatial autocorrelation. You will learn more about this later on. Another reason why variables reported for areas could display similarities in space is as an consequence of the zoning system. Suppose for a moment that the data above can only be reported at the zonal level, perhaps because of privacy and confidentiality concerns. Thanks to the great talent of the designers of the zoning system (or a felicitous coincidence!), the zoning system is such that it is consistent with the underlying process of sorting. The zones, therefore, are as follows: zones1 &lt;- data.frame(x1=c(0.2, 0.45), x2=c(0.45, 0.80), y1=c(0.0, 0.0), y2=c(0.6, 0.6), Zone_ID = c(&#39;1&#39;,&#39;2&#39;)) If you add these zones to the plot: p &lt;- ggplot() + geom_rect(data = zones1, mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2, fill = Zone_ID), alpha = 0.3) + geom_point(data = df, aes(x = x, y = y, color = Income), shape = 17, size = 5) + coord_fixed() ggplotly(p) What is the mean income in zone 1? What is the mean income in zone 2? Not only are the summary measures of income highly representative of the observations they describe, the two zones are also highly distinct. Imagine now that for whatever reason (lack of prior knowledge of the process, convenience for data collection, etc.) the zones instead are as follows: zones2 &lt;- data.frame(x1=c(0.2, 0.55), x2=c(0.55, 0.80), y1=c(0.0, 0.0), y2=c(0.6, 0.6), Zone_ID = c(&#39;1&#39;,&#39;2&#39;)) If you plot these zones: p &lt;- ggplot() + geom_rect(data = zones2, mapping = aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2, fill = Zone_ID), alpha = 0.3) + geom_point(data = df, aes(x = x, y = y, color = Income), shape = 17, size = 5) + coord_fixed() ggplotly(p) What is now the mean income of zone 1? What is the mean income of zone 2? The observations have not changed, and the generating spatial process remains the same. You will notice, however, that the summary measures for the two zones are more similar in this case than they were when the zones more closely captured the underlying process. 19.6 Visualizing Area Data: Choropleth Maps The initial step when working with spatial area data, perhaps, is to visualize the data. Commonly, area data are visualized by means of choropleth maps. A choropleth map is a map of the polygons that form the areas in the region, each colored in a way to represent the value of an underlying variable. Lets use ggplot2 to create a choropleth map of population in Hamilton. Notice that the fill color for the polygons is given by cutting the values of POPULATION in five equal segments. In other words, the colors represent zones in the bottom 20% of population, zones in the next 20%, and so on, so that the darkest zones are those with populations so large as to be in the top 20% of the population distribution: ggplot(Hamilton_CT) + geom_sf(aes(fill = cut_number(Hamilton_CT$POPULATION, 5)), color = NA, size = 0.1) + scale_fill_brewer(palette = &quot;YlOrRd&quot;) + coord_sf() + labs(fill = &quot;Population&quot;) Inspecting the map above, would you say that the distribution of population is random, or not random? If not random, what do you think might be an underlying process for the distribution of population. Often, creating a choropleth map using the absolute value of a variable can be somewhat misleading. As seen in the map above, the zones with the largest population are also usually large zones. Any process that you might think of will be confounded by the size of the zones. For this reason, it is often more informative when creating a choropleth map to use a variable that is a rate, for instance population divided by area to give population density: pop_den.map &lt;- ggplot(Hamilton_CT) + geom_sf(aes(fill = cut_number(Hamilton_CT$POP_DENSITY, 5)), color = &quot;white&quot;, size = 0.1) + scale_fill_brewer(palette = &quot;YlOrRd&quot;) + labs(fill = &quot;Pop Density&quot;) pop_den.map It can be seen now that the population density is higher in the more central parts of Hamilton, Burlington, Dundas, etc. Does the map look random? If not, what might be an underlying process that explains the variations in population density in a city like Hamilton? Other times, it is appropriate to standardize instead of by area, by what might be called the population at risk. For instance, lets say that we wanted to explore the distribution of the population of older adults (say, 65 and older). In this case, normalizing not by area, but by the total population, would remove the “size” effect, giving a proportion: ggplot(Hamilton_CT) + geom_sf(aes(fill = cut_number((Hamilton_CT$AGE_65_TO_69 + Hamilton_CT$AGE_70_TO_74 + Hamilton_CT$AGE_75_TO_79 + Hamilton_CT$AGE_80_TO_84 + Hamilton_CT$AGE_MORE_85) / Hamilton_CT$POPULATION, 5)), color = NA, size = 0.1) + scale_fill_brewer(palette = &quot;YlOrRd&quot;) + labs(fill = &quot;Prop Age 65+&quot;) Do you notice a pattern in the distribution of seniors in the Hamilton, CMA? There are a few things to keep in mind when creating choroplet maps. First, what classification scheme to use, with how many classes, and what colors? The examples above were all created using a classification scheme based on the quintiles of the distribution. As noted above, these are obtained by dividing the sample into 5 equal parts to give bottom 20%, etc., of observations. The quintiles are a particular form of a statistical measure known as quantiles, of which the median is value obtained when the sample is divided in two equal sized parts. Other classification schemes may include the mean, standard deviation, and so on. In terms of how many classes to use, often there is little point in using more than six or seven classes, because the human eye cannot distinguish color differences at a much higher resolution. The colors are a matter of style, but there are coloring schemes that are colorblind safe (see here). Secondly, when the zoning system is irregular (as opposed to, say, a raster), large zones can easily become dominant. In effect, much detail in the maps above is lost for small zones, whereas large zones, especially if similarly colored, may mislead the eye as to their relative frequency. Another mapping technique, the cartogram, is meant to reduce the issues with small-large zones. 19.7 Visualizing Area Data: Cartograms A cartogram is a map where the size of the zones is adjusted so that instead of being the land area, it is proportional to some other variable of interest. Lets illustrate the idea behind the cartogram here. In the maps above, the zones are faithful to their geographical properties. Unfortunately, this obscured the relevance of small zones. A cartogram can be weighted by another variable, say for instance, the population. In this way, the size of the zones will depend on the total population. Cartograms are implemented in R in the package cartogram. CT_pop_cartogram &lt;- cartogram_cont(as(Hamilton_CT, &quot;Spatial&quot;), &quot;POPULATION&quot;) ## Mean size error for iteration 1: 5.93989832705797 ## Mean size error for iteration 2: 4.22003636161907 ## Mean size error for iteration 3: 3.22484467962666 ## Mean size error for iteration 4: 2.67349944741397 ## Mean size error for iteration 5: 2.39730255727434 ## Mean size error for iteration 6: 2.27353151789255 ## Mean size error for iteration 7: 2.21619358572193 ## Mean size error for iteration 8: 2.1621830846263 ## Mean size error for iteration 9: 2.10302324046727 ## Mean size error for iteration 10: 1.97693517836395 ## Mean size error for iteration 11: 1.83404151346793 ## Mean size error for iteration 12: 1.68895026525741 ## Mean size error for iteration 13: 1.48501500944163 ## Mean size error for iteration 14: 1.32015982874586 ## Mean size error for iteration 15: 1.25319335368508 Notice that the value of the function cartogram (i.e., its output) is a SpatialPolygonsDataFrame. This object needs to be converted to an object of class sf if we wish to use ggplot2 to visualize it: CT_pop_cartogram.t &lt;- st_as_sf(CT_pop_cartogram) Plotting the cartogram: ggplot(CT_pop_cartogram.t) + geom_sf(aes(fill = cut_number(Hamilton_CT$POPULATION, 5)), color = &quot;white&quot;, size = 0.1) + scale_fill_brewer(palette = &quot;YlOrRd&quot;) + labs(fill = &quot;Population&quot;) Notice how the size of the zones has been adjusted. The cartogram can be combined with coloring schemes, as in choropleth maps: CT_popden_cartogram &lt;- cartogram(as(Hamilton_CT, &quot;Spatial&quot;), weight = &quot;POP_DENSITY&quot;) ## ## Please use cartogram_cont() instead of cartogram(). ## Mean size error for iteration 1: 29.038428707007 ## Mean size error for iteration 2: 26.8741045865025 ## Mean size error for iteration 3: 25.1188420421205 ## Mean size error for iteration 4: 23.62794892945 ## Mean size error for iteration 5: 22.3098917140505 ## Mean size error for iteration 6: 21.106667145772 ## Mean size error for iteration 7: 19.9815506326308 ## Mean size error for iteration 8: 18.9106321110581 ## Mean size error for iteration 9: 17.8793922806811 ## Mean size error for iteration 10: 16.8783214422446 ## Mean size error for iteration 11: 15.9023828765327 ## Mean size error for iteration 12: 14.9493939574685 ## Mean size error for iteration 13: 14.0197712378282 ## Mean size error for iteration 14: 13.115878344782 ## Mean size error for iteration 15: 12.2410530253921 Tidy and restore the data: CT_popden_cartogram.t &lt;- st_as_sf(CT_popden_cartogram) pop_den.cartogram &lt;- ggplot(CT_popden_cartogram.t) + geom_sf(aes(fill = cut_number(Hamilton_CT$POP_DENSITY, 5)),color = &quot;white&quot;, size = 0.1) + scale_fill_brewer(palette = &quot;YlOrRd&quot;) + labs(fill = &quot;Pop Density&quot;) pop_den.cartogram By combining a cartogram with choropleth mapping, it becomes easier to appreciate the way high population density is concentrated in the central parts of Hamilton, Burlington, etc. grid.arrange(pop_den.map, pop_den.cartogram, nrow = 2) This concludes this chapter. "],
["activity-9-area-data-i.html", "Chapter 20 Activity 9: Area Data I 20.1 Practice questions 20.2 Learning objectives 20.3 Suggested reading 20.4 Preliminaries 20.5 Activity", " Chapter 20 Activity 9: Area Data I Remember, you can download the source file for this activity from here. 20.1 Practice questions Answer the following questions: What is a key difference between area data and point data? What is a choropleth map? What is a cartogram? What are the advantages and disadvantages of these mapping techniques? 20.2 Learning objectives In this activity, you will: Create choroplet maps using census data. Think about possible underlying process that could explain the pattern. Think about ways to decide whether a landscape is random when working with area data. 20.3 Suggested reading O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 7. John Wiley &amp; Sons: New Jersey. 20.4 Preliminaries For this activity you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity. In addition to tidyverse, you will need sf, a package that implements simple features in R (you can learn more about this package here): library(tidyverse) library(sf) library(cartogram) library(geog4ga3) In the practice that preceded this activity, you learned about the area data and visualization techniques for area data. Begin by loading the data that you will use in this activity: data(&quot;Hamilton_CT&quot;) This is a sf object with census tracts and selected demographic variables for the Hamilton CMA in Canada. You can obtain new (calculated) variables as follows. For instance, to obtain the proportion of residents who are between 20 and 34 years old, and between 35 and 49: Hamilton_CT &lt;- mutate(Hamilton_CT, Prop20to34 = (AGE_20_TO_24 + AGE_25_TO_29 + AGE_30_TO_34)/POPULATION, Prop35to49 = (AGE_35_TO_39 + AGE_40_TO_44 + AGE_45_TO_49)/POPULATION) You are ready for the next activity. 20.5 Activity Create choropleth maps for the proportion of the population who are 20 to 34 years old, 35 to 49 years old, 50 to 65 years old, and 65 and older. Show your maps to a fellow student. What patterns do you notice in the distribution of age in Hamilton? Devise a rule to decide whether the pattern observed in a choropleth map is random. "],
["area-data-ii.html", "Chapter 21 Area Data II 21.1 Learning Objectives 21.2 Suggested Readings 21.3 Preliminaries 21.4 Proximity in Area Data 21.5 Spatial Weights Matrices 21.6 Creating Spatial Weights Matrices in R 21.7 Spatial Moving Averages 21.8 Other Criteria for Coding Proximity", " Chapter 21 Area Data II NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. In last chapter and activity, you learned about area data and practiced some visualization techniques for spatial data of this type, specifically choropleth maps and cartograms. You also thought about rules to decide whether a mapped variable displayed a spatially random distribution of values. If you wish to work interactively with this chapter you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. 21.1 Learning Objectives In this practice, you will learn about: The concept of proximity for area data. How to formalize the concept of proximity: spatial weights matrices. How to create spatial weights matrices in R. The use of spatial moving averages. Other criteria for coding proximity. 21.2 Suggested Readings Bailey TC and Gatrell AC (1995) Interactive Spatial Data Analysis, Chapter 7. Longman: Essex. Bivand RS, Pebesma E, and Gomez-Rubio V (2008) Applied Spatial Data Analysis with R, Chapter 9. Springer: New York. Brunsdon C and Comber L (2015) An Introduction to R for Spatial Analysis and Mapping, Chapter 7. Sage: Los Angeles. O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 7. John Wiley &amp; Sons: New Jersey. 21.3 Preliminaries As usual, it is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) library(sf) library(plotly) library(spdep) library(geog4ga3) Read the data to be used in this chapter. The data is an object of class sf (simple feature) with the census tracts of Hamilton CMA in Canada, and a selection of demographic variables: data(Hamilton_CT) You can quickly verify the contents of the dataframe by means of summary: summary(Hamilton_CT) ## ID AREA TRACT POPULATION ## Min. : 919807 Min. : 0.3154 Length:188 Min. : 5 ## 1st Qu.: 927964 1st Qu.: 0.8552 Class :character 1st Qu.: 2639 ## Median : 948130 Median : 1.4157 Mode :character Median : 3595 ## Mean : 948710 Mean : 7.4578 Mean : 3835 ## 3rd Qu.: 959722 3rd Qu.: 2.7775 3rd Qu.: 4692 ## Max. :1115750 Max. :138.4466 Max. :11675 ## POP_DENSITY AGE_LESS_20 AGE_20_TO_24 AGE_25_TO_29 ## Min. : 2.591 Min. : 0.0 Min. : 0.0 Min. : 0.0 ## 1st Qu.: 1438.007 1st Qu.: 528.8 1st Qu.:168.8 1st Qu.:135.0 ## Median : 2689.737 Median : 750.0 Median :225.0 Median :215.0 ## Mean : 2853.078 Mean : 899.3 Mean :253.9 Mean :232.8 ## 3rd Qu.: 3783.889 3rd Qu.:1110.0 3rd Qu.:311.2 3rd Qu.:296.2 ## Max. :14234.286 Max. :3285.0 Max. :835.0 Max. :915.0 ## AGE_30_TO_34 AGE_35_TO_39 AGE_40_TO_44 AGE_45_TO_49 ## Min. : 0.0 Min. : 0.0 Min. : 0.0 Min. : 0.0 ## 1st Qu.: 135.0 1st Qu.: 145.0 1st Qu.: 170.0 1st Qu.:203.8 ## Median : 195.0 Median : 200.0 Median : 230.0 Median :282.5 ## Mean : 228.2 Mean : 239.6 Mean : 268.7 Mean :310.6 ## 3rd Qu.: 281.2 3rd Qu.: 280.0 3rd Qu.: 325.0 3rd Qu.:385.0 ## Max. :1320.0 Max. :1200.0 Max. :1105.0 Max. :880.0 ## AGE_50_TO_54 AGE_55_TO_59 AGE_60_TO_64 AGE_65_TO_69 ## Min. : 0.0 Min. : 0.0 Min. : 0 Min. : 0.0 ## 1st Qu.:203.8 1st Qu.:175.0 1st Qu.:140 1st Qu.:115.0 ## Median :280.0 Median :240.0 Median :220 Median :157.5 ## Mean :300.3 Mean :257.7 Mean :229 Mean :174.2 ## 3rd Qu.:375.0 3rd Qu.:325.0 3rd Qu.:295 3rd Qu.:221.2 ## Max. :740.0 Max. :625.0 Max. :540 Max. :625.0 ## AGE_70_TO_74 AGE_75_TO_79 AGE_80_TO_84 AGE_MORE_85 ## Min. : 0.0 Min. : 0.00 Min. : 0.00 Min. : 0.00 ## 1st Qu.: 90.0 1st Qu.: 68.75 1st Qu.: 50.00 1st Qu.: 35.00 ## Median :130.0 Median :100.00 Median : 77.50 Median : 70.00 ## Mean :139.7 Mean :118.32 Mean : 95.05 Mean : 87.71 ## 3rd Qu.:180.0 3rd Qu.:160.00 3rd Qu.:120.00 3rd Qu.:105.00 ## Max. :540.0 Max. :575.00 Max. :420.00 Max. :400.00 ## geometry ## POLYGON :188 ## epsg:26917 : 0 ## +proj=utm ...: 0 ## ## ## 21.4 Proximity in Area Data In the earlier part of the text, when working with point data, the spatial relationships among events (their proximity) were more or less unambiguously given by their relative location, or more precisely by their distance. Hence, we had quadrat-based techniques (relative location with respect to a grid) and distance-based techniques (event-to-event and point-to-event). In the case of area data, spatial proximity can be represented in more ways, given the characteristics of areas. In particular, an area contains an infinite number of points, and measuring distance between two areas leads to many possible results, depending on which pairs of points within two zones are used to measure the distance. Consider the simple systems shown in Figure @ref{fig:simple-zoning-system}. Which of zones \\(A_2\\), \\(A_3\\), and \\(A_4\\) is more proximate to \\(A_1\\)? Figure 21.1: Simple zoning system If points are selected in such a way that they are on the overlapping edges of two contiguous areas, the distance between the two areas clearly is zero, and they must be proximate. This criterion to define proximity is called adjacency. Adjacency means that two zones share a common edge. This is conventionally called the rook criterion, after chess, in which the piece called the rook can move only orthogonally. The rook criterion, however, would dictate that zones \\(A_2\\) and \\(A_6\\) are not proximate, despite being closer than \\(A_2\\) and \\(A_3\\). When this criterion is expanded to allow contact at a single point between zones (say, the corner between \\(A_2\\) and \\(A_6\\)), the adjacency criterion is called queen, again, for the chess piece that moves both orthogonally and diagonally. If we accept adjacency as a reasonable way of expressing relationships of proximity between areas, what we need is a way of coding relationships of adjacency in a way that is convenient and amenable to manipulation for data analysis. One of the most widely used tools to code proximity in area data is the spatial weights matrix. 21.5 Spatial Weights Matrices A spatial weights matrix is an arrangement of values (or weights) for all pairs of zones in a system. For instance, in a zoning system such as shown in Figure 1, with 6 zones, there will be \\(6 \\times 6\\) such weights. The weights are organized by rows, in such a way that each zone has a corresponding row of weights. For example, zone \\(A_1\\) in Figure 1 has weights: \\[ w_{1\\cdot} = [w_{11}, w_{12}, w_{13}, w_{14}, w_{15}, w_{16}] \\] The values of the weights depend on the adjacency criterion adopted. The simplest coding scheme is when we assign a value of 1 to pairs of zones that are adjacent, and a value of 0 to pairs of zones that are not. Lets formalize the two criteria mentioned above: Rook criterion \\[ w_{ij}=\\bigg\\{\\begin{array}{l l} 1\\text{ if } A_i \\text{ and } A_j \\text{ share an edge}\\\\ 0\\text{ otherwise}\\\\ \\end{array} \\] Queen criterion \\[ w_{ij}=\\bigg\\{\\begin{array}{l l} 1\\text{ if } A_i \\text{ and } A_j \\text{ share an edge or a vertex}\\\\ 0\\text{ otherwise}\\\\ \\end{array} \\] If queen adjacency is used, the weights for zone \\(A_6\\) are as follows: \\[ w_{6\\cdot} = [0, 1, 0, 1, 1, 0]. \\] As you can see, the adjacent areas from the perspective of \\(A_6\\) are \\(A_4\\) and \\(A_5\\) (by virtue of sharing an edge), and \\(A_2\\) (by virtue of sharing a vertex). These three areas receive weights of 1. On the other hand, \\(A_1\\) and \\(A_3\\) are not adjacent, and therefore receive a weight of zero. Notice how the weight \\(w_{66}\\) is set to zero. By convention, an area is not its own neighbor! The set of weights above define the neighborhood of \\(A_6\\). The spatial weights matrix for the whole system in Figure 1 is as follows: \\[ \\textbf{W}=\\left (\\begin{array}{c c c c c c} 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\\\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0\\\\ \\end{array} \\right). \\] Compare the matrix to the zoning system. The spatial weights matrix has the following properties: The main diagonal elements are all zeros (no area is its own neighbor). Each zone has a row of weights in the matrix: row number one corresponds to \\(A_1\\), row number two corresponds to \\(A_2\\), and so on. Likewise, each zone has a column of weights. The sum of all values in a row gives the total number of neighbors for an area. That is: \\[ \\text{The total number of neighbors of } A_i \\text{ is given by: }\\sum_{j=1}^{n}{w_{ij}} \\] The spatial weights matrix is often processed to obtain a row-standardized spatial weights matrix. This procedure consists of dividing all weights by the sum of their corresponding row (i.e., by the total number of neighbors), as follows: \\[ w_{ij}^{st}=\\frac{w_{ij}}{\\sum_{j=1}^n{w_{ij}}} \\] The row-standardized weights matrix for the system in Figure 1 is: \\[ \\textbf{W}^{st}=\\left (\\begin{array}{c c c c c c} 0 &amp; 1/3 &amp; 1/3 &amp; 1/3 &amp; 0 &amp; 0\\\\ 1/4 &amp; 0 &amp; 0 &amp; 1/4 &amp; 1/4 &amp; 1/4\\\\ 1/2 &amp; 0 &amp; 0 &amp; 1/2 &amp; 0 &amp; 0\\\\ 1/5 &amp; 1/5 &amp; 1/5 &amp; 0 &amp; 1/5 &amp; 1/5\\\\ 0 &amp; 1/3 &amp; 0 &amp; 1/3 &amp; 0 &amp; 1/3\\\\ 0 &amp; 1/3 &amp; 0 &amp; 1/3 &amp; 1/3 &amp; 0\\\\ \\end{array} \\right). \\] The row-standardized spatial weights matrix has the following properties: Each weight now represents the proportion of a neighbor out of the total of neighbors. For instance, since the total of neighbors of \\(A_1\\) is 3, each neighbor contributes 1/3 to that total. The sum of all weights over a row equals 1, or 100% of all neighbors for that zone. 21.6 Creating Spatial Weights Matrices in R Coding spatial weights matrices by hand is a tedious and error-prone process. Fortunately, functions to generate them exist in R. The package spdep, for instance, has a number of useful utilities for working with spatial weights matrices. The first step to create a spatial weights matrix is to find the neighbors (i.e., areas adjacent to) for each area. The function poly2nb is used for this. The input argument is a SpatialPolygonDataFrame. This means that our sf object needs to be converted into a SpatialPolygonDataFrame: Hamilton_CT.sp &lt;- as(Hamilton_CT, &quot;Spatial&quot;) The following finds the neighbors (note that the default adjacency criterion is queen): Hamilton_CT.nb &lt;- poly2nb(pl = Hamilton_CT.sp, queen = TRUE) The value (output) of the function is an object of class nb: class(Hamilton_CT.nb) ## [1] &quot;nb&quot; The function summary applied to an object of this class gives some useful information about the neighbors, including the number of areas in this system (188), the total number of neighbors (1180), and the percentage of neighbors out of all pairs of areas (3.34%). Other information includes the distribution of neighbors (3 zones have two neighbors, 8 zones have three neighbors, 22 zones have four neighbors, and so on): summary(Hamilton_CT.nb) ## Neighbour list object: ## Number of regions: 188 ## Number of nonzero links: 1180 ## Percentage nonzero weights: 3.338615 ## Average number of links: 6.276596 ## Link number distribution: ## ## 2 3 4 5 6 7 8 9 10 11 12 14 ## 3 8 22 32 35 45 30 6 1 1 4 1 ## 3 least connected regions: ## 174 175 188 with 2 links ## 1 most connected region: ## 33 with 14 links The nb object is a list that contains the neighbors for each area. For instance, the neighbors of census tract 5370001.01 (the first tract in the dataframe) are the following tracts: Hamilton_CT$TRACT[Hamilton_CT.nb[[1]]] ## [1] &quot;5370120.02&quot; &quot;5370122.01&quot; &quot;5370122.02&quot; &quot;5370124.00&quot; &quot;5370142.01&quot; ## [6] &quot;5370133.01&quot; &quot;5370130.03&quot; The list of neighbors can be converted into a list of entries in a spatial weights matrix W by means of the function nb2list2 (for “neighbors to W in list form”): Hamilton_CT.w &lt;- nb2listw(Hamilton_CT.nb) We can visualize the neighbors (adjacent) areas: plot(Hamilton_CT.sp, border = &quot;gray&quot;) plot(Hamilton_CT.nb, coordinates(Hamilton_CT.sp), col = &quot;red&quot;, add = TRUE) 21.7 Spatial Moving Averages The spatial weights matrix, and in particular its row-standardized version, is useful to calculate a spatial statistic, the spatial moving average. The spatial moving average is a variation on the mean statistic. Recall that the mean is calculated as the sum of all relevant values divided by the number of values summed. In the case of spatial data, the mean is what we would call a global statistics, since it is calculated using all data for a region: \\[ \\overline{x}=\\frac{1}{n}\\sum_{j=1}^{n}{x_j} \\] where \\(\\overline{x}\\) (read x-bar) is the mean of all values of x. A spatial moving average is calculated in the same way, but for each area, and based only on the values of proximate areas: \\[ \\overline{x_i}=\\frac{1}{n_i}\\sum_{j\\in N(i)}{x_j} \\] where \\(n_i\\) is the number of neighbors of \\(A_i\\), and the sum is only for \\(x_j\\) that are in the neighborhood of i (\\(j\\in N(i)\\) is read “j in the neighborhood of i”). Lets illustrate this by making reference again to Figure 1. Consider \\(A_1\\). The spatial weights matrix indicates that the neighborhood of \\(A_1\\) consists of three areas: \\(A_2\\), \\(A_3\\), and \\(A_4\\). Therefore \\(n_1=3\\), and \\(j\\in N(1)\\) are 2, 3, and 4. The spatial moving average of \\(A_1\\) for a variable \\(x\\) would then be calculated as: \\[ \\overline{x_1}=\\frac{x_2 + x_3 + x_4}{3} \\] Notice that another way of writing the spatial moving average expression is as follows, since membership in the neighborhood of \\(i\\) is implicit in the definition of \\(w_{ij}\\)! Since \\(w_{ij}\\) takes values of zero and one, the effect is to turn on and off the values of \\(x\\) depending on whether they are for areas adjacent to \\(i\\): \\[ \\overline{x_i}=\\frac{1}{n_i}\\sum_{j=1}^n{w_{ij}x_j} \\] This means that the spatial moving average of \\(A_1\\) for a variable \\(x\\) on this system can also be calculated using the spatial weights matrix as: \\[ \\overline{x_1}=\\frac{w_{11}x_1 + w_{12}x_2 + w_{13}x_3 + w_{14}x_4 + w_{15}x_5 + w_{12}x_6}{3} \\] Substituting the spatial weights: \\[ \\overline{x_1}=\\frac{0x_1 + 1x_2 + 1x_3 + 1x_4 + 0x_5 + 0x_6}{3} = \\frac{x_2 + x_3 + x_4}{3} \\] In other words, the spatial weights can be used directly in the calculation of spatial moving averages. Further, notice that: \\[ n_i=\\sum_{j=1}^{n}w_{ij} \\] which is simply the total number of neighbors of \\(A_i\\), and the value we used to row-standardize the spatial weights. Since the row-standardized weights have already been divided by the number of neighbors, we can use them to express the spatial moving average as follows: \\[ \\overline{x_i}=\\sum_{j=1}^{n}{w_{ij}^{st}x_j} \\] Continuing the example, if we use the row-standardized weights, the spatial moving average at \\(A_1\\) is: \\[ \\overline{x_i}=0x_1 + \\frac{1}{3}x_2 + \\frac{1}{3}x_3 + \\frac{1}{3}x_4 + 0x_5 + 0x_6 \\] which is the same as: \\[ \\overline{x_i}=\\frac{x_2 + x_3 + x_4}{3} \\] Consider the following map of Hamilton’s population density: map &lt;- ggplot(data = Hamilton_CT) + geom_sf(aes(fill = cut_number(Hamilton_CT$POP_DENSITY, 5), POP_DENSITY = round(POP_DENSITY), TRACT = TRACT), color = &quot;black&quot;) + geom_sf(data = subset(Hamilton_CT, TRACT == &quot;5370142.02&quot;), aes(POP_DENSITY = round(POP_DENSITY), TRACT = TRACT), color = &quot;red&quot;, weight = 3, fill = NA) + geom_sf(data = subset(Hamilton_CT, TRACT == &quot;5370144.01&quot;), aes(POP_DENSITY = round(POP_DENSITY), TRACT = TRACT), color = &quot;green&quot;, weight = 3, fill = NA) + scale_fill_brewer(palette = &quot;YlOrRd&quot;) + labs(fill = &quot;Pop Density&quot;) + coord_sf() ggplotly(map, tooltip = c(&quot;TRACT&quot;, &quot;POP_DENSIT&quot;)) Manually calculate the spatial moving average for tract 5370142.02 (with the red boundary) and tract (with the green boundary). Tip: hover over the tracts to see their population densities. (32 + 109 + 48)/3 ## [1] 63 (48 + 55 + 125)/3 ## [1] 76 Spatial moving averages can be calculated in a straighforward way by means of the function lag.listw function of the spdep package. This function uses a spatial weights matrix and automatically selects the row-standardized weights. Lets calculate the spatial moving average of population density: POP_DENSITY.sma &lt;- lag.listw(x = Hamilton_CT.w, Hamilton_CT$POP_DENSITY) Lets now plot the spatial moving average of population density. First we add this variable to our tidy dataframe: Hamilton_CT &lt;- left_join(Hamilton_CT, data.frame(TRACT = Hamilton_CT$TRACT, POP_DENSITY.sma)) ## Joining, by = &quot;TRACT&quot; ## Warning: Column `TRACT` joining character vector and factor, coercing into ## character vector And plot: map.sma &lt;- ggplot() + geom_sf(data = Hamilton_CT, aes(fill = cut_number(Hamilton_CT$POP_DENSITY.sma, 5), POP_DENSITY.sma = round(POP_DENSITY.sma), TRACT = TRACT), color = &quot;black&quot;) + geom_sf(data = subset(Hamilton_CT, TRACT == &quot;5370142.02&quot;), aes(POP_DENSITY.sma = round(POP_DENSITY.sma), TRACT = TRACT), color = &quot;red&quot;, weight = 3, fill = NA) + geom_sf(data = subset(Hamilton_CT, TRACT == &quot;5370144.01&quot;), aes(POP_DENSITY.sma = round(POP_DENSITY.sma), TRACT = TRACT), color = &quot;green&quot;, weight = 3, fill = NA) + scale_fill_brewer(palette = &quot;YlOrRd&quot;) + labs(fill = &quot;Pop Density SMA&quot;) + coord_sf() ggplotly(map.sma, tooltip = c(&quot;TRACT&quot;, &quot;POP_DENSIT.sma&quot;)) Verify that your manual calculations for the two tracts above are correct. What differences do you notice between the map of population density and the map of spatial moving averages of population density? 21.8 Other Criteria for Coding Proximity Adjacenty is not the only criterion for coding proximity. Occasionally, the distance between areas is calculated by using the centroids of the areas as their representative points. A centroid is simply the mean of the coordinates of the edges of an area, and in this way represent the “centre of gravity” of the area. The inter-centroid distance allows us to define additional criteria for proximity, including neighbors within a certain distance threshold, and k-nearest neighbors. Distance-based criterion \\[ w_{ij}=\\bigg\\{\\begin{array}{l l} 1\\text{ if inter-centroid distance } d_{ij}\\leq \\delta\\\\ 0\\text{ otherwise}\\\\ \\end{array} \\] where \\(\\delta\\) is a distance threshold. Distance-based nearest neighbors can be obtained in R by means of the function dnearneigh. First we need to obtain the coordinates of the centroids of the areas. These are the first two columns of the output of st_coordinates function: CT_centroids &lt;- coordinates(Hamilton_CT.sp) A nearest neighbors object nb is produced as follows (selecting a distance threshold between 0 and 5 km): Hamilton_CT.dnb &lt;- dnearneigh(CT_centroids, d1 = 0, d2 = 5000) We can visualize the neighbors (adjacent) areas: plot(Hamilton_CT.sp, border = &quot;gray&quot;) plot(Hamilton_CT.dnb, CT_centroids, col = &quot;red&quot;, add = TRUE) Try changing the distance threshold to see how different neighborhoods are defined. \\(k\\)-nearest neighbors \\[ w_{ij}=\\bigg\\{\\begin{array}{l l} 1\\text{ if } A_j \\text{ is one of k-nearest neighbors of } A_i\\\\ 0\\text{ otherwise}\\\\ \\end{array} \\] A potential disadvantage of using a distance-based criterion is that for zoning systems with areas of vastly different sizes, small areas will end up having many neighbors, whereas large areas will have few or none. The criterion of \\(k\\)-nearest neighbors allows for some adaptation to the size of the areas. Under this criterion, all areas have the exact same number of neighbors, but the geographical extent of the neighborhood may (and likely will) change. In R, \\(k\\)-nearest neighbors can be obtained by means of the function knearneigh, and the arguments include the value of \\(k\\): Hamilton_CT.knb &lt;- knn2nb(knearneigh(CT_centroids, k = 3)) We can again visualize the neighbors (“adjacent”) areas: plot(Hamilton_CT.sp, border = &quot;gray&quot;) plot(Hamilton_CT.knb, CT_centroids, col = &quot;red&quot;, add = TRUE) Try changing the value of k to see how the neighborhoods change. "],
["activity-10-area-data-ii.html", "Chapter 22 Activity 10: Area Data II 22.1 Practice questions 22.2 Learning objectives 22.3 Suggested reading 22.4 Preliminaries 22.5 Activity", " Chapter 22 Activity 10: Area Data II Remember, you can download the source file for this activity from here. 22.1 Practice questions Answer the following questions: List and describe two criteria to define proximity in area data analysis. What is a spatial weights matrix? Why do spatial weight matrices have zeros in the main diagonal? How is a spatials weights matrix row-standardized? Write the spatial weights matrices for the sample systems in Figures @ref{fig:simple-areal-system-i} and @ref{fig:simple-areal-system-ii}. Explain the criteria used to do so. Figure 22.1: Sample areal system 1 Figure 22.2: Sample areal system 2 22.2 Learning objectives In this activity, you will: Create spatial weights matrices. Calculate the spatial moving average of a variable. Create scatterplots of a variable and its spatial moving average. Think about ways to decide whether a landscape is random when working with area data. 22.3 Suggested reading O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 7. John Wiley &amp; Sons: New Jersey. 22.4 Preliminaries For this activity you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity. In addition to tidyverse, you will need sf, a package that implements simple features in R (you can learn about sf here) and spdep, a package that implements several spatial statistical methods (you can learn more about it here): library(tidyverse) library(spdep) library(sf) library(geog4ga3) library(plotly) In the practice that preceded this activity, you learned about the area data and visualization techniques for area data. Begin by loading the data that you will use in this activity: data(Hamilton_CT) This is a sf object with census tracts and selected demographic variables for the Hamilton CMA in Canada. You can obtain new (calculated) variables as follows. For instance, to obtain the proportion of residents who are between 20 and 34 years old, and between 35 and 49: Hamilton_CT &lt;- mutate(Hamilton_CT, Prop20to34 = (AGE_20_TO_24 + AGE_25_TO_29 + AGE_30_TO_34)/POPULATION, Prop35to49 = (AGE_35_TO_39 + AGE_40_TO_44 + AGE_45_TO_49)/POPULATION) You can also convert the sf object into a SpatialPolygonsDataFrame object for use with the spdedp package: Hamilton_CT.sp &lt;- as(Hamilton_CT, &quot;Spatial&quot;) You are now ready for the next activity. 22.5 Activity Create a spatial weights matrix for the census tracts in the Hamilton CMA. Calculate the proportion of spatial moving average for the proportion of the population who are 20 to 34 years old, 35 to 49 years old, 50 to 65 years old, and 65 and older. Append the spatial moving averages to your dataframe. Choose one age group and create a scatterplot of the proportion of population in that group versus its spatial moving average. (Hint: if creating the scatterplot in ggplot2 you can add the 45 degree line by using geom_abline(slope = 1, intercept = 0)). What would you expect the scatterplots of the variables and their spatial moving averages to look like if the variable was spatially random? Discuss. "],
["area-data-iii.html", "Chapter 23 Area Data III 23.1 Learning Objectives 23.2 Suggested Readings 23.3 Preliminaries 23.4 Spatial Moving Averages and Simulation 23.5 The Spatial Moving Average as a Smoother 23.6 Spatial Moving Average Scatterplots 23.7 Spatial Autocorrelation and Moran’s \\(I\\) coefficient 23.8 Moran’s \\(I\\) and Moran’s Scatterplot 23.9 Hypothesis Testing for Spatial Autocorrelation", " Chapter 23 Area Data III NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. In preceding chapter and activity, you learned about different ways to define proximity for area data, about spatial weights matrices, and how spatial weights matrices could be used to calculate spatial moving averages. If you wish to work interactively with this chapter you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. 23.1 Learning Objectives In this practice, you will learn about: Spatial moving averages and simulation. The concept of spatial autocorrelation. Moran’s I coefficient and Moran’s scatterplot. Hypothesis testing for spatial autocorrelation. 23.2 Suggested Readings Bailey TC and Gatrell AC (1995) Interactive Spatial Data Analysis, Chapter 7. Longman: Essex. Bivand RS, Pebesma E, and Gomez-Rubio V (2008) Applied Spatial Data Analysis with R, Chapter 9. Springer: New York. Brunsdon C and Comber L (2015) An Introduction to R for Spatial Analysis and Mapping, Chapter 7. Sage: Los Angeles. O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 7. John Wiley &amp; Sons: New Jersey. 23.3 Preliminaries As usual, it is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) library(spdep) library(sf) library(geog4ga3) #library(reshape2) library(gridExtra) Read the data used in this chapter. This is an object of class sf (simple feature) with the census tracts of Hamilton CMA and some selected population variables from the 2011 Census of Canada: data(Hamilton_CT) You can quickly verify the contents of the dataframe by means of summary: summary(Hamilton_CT) ## ID AREA TRACT POPULATION ## Min. : 919807 Min. : 0.3154 Length:188 Min. : 5 ## 1st Qu.: 927964 1st Qu.: 0.8552 Class :character 1st Qu.: 2639 ## Median : 948130 Median : 1.4157 Mode :character Median : 3595 ## Mean : 948710 Mean : 7.4578 Mean : 3835 ## 3rd Qu.: 959722 3rd Qu.: 2.7775 3rd Qu.: 4692 ## Max. :1115750 Max. :138.4466 Max. :11675 ## POP_DENSITY AGE_LESS_20 AGE_20_TO_24 AGE_25_TO_29 ## Min. : 2.591 Min. : 0.0 Min. : 0.0 Min. : 0.0 ## 1st Qu.: 1438.007 1st Qu.: 528.8 1st Qu.:168.8 1st Qu.:135.0 ## Median : 2689.737 Median : 750.0 Median :225.0 Median :215.0 ## Mean : 2853.078 Mean : 899.3 Mean :253.9 Mean :232.8 ## 3rd Qu.: 3783.889 3rd Qu.:1110.0 3rd Qu.:311.2 3rd Qu.:296.2 ## Max. :14234.286 Max. :3285.0 Max. :835.0 Max. :915.0 ## AGE_30_TO_34 AGE_35_TO_39 AGE_40_TO_44 AGE_45_TO_49 ## Min. : 0.0 Min. : 0.0 Min. : 0.0 Min. : 0.0 ## 1st Qu.: 135.0 1st Qu.: 145.0 1st Qu.: 170.0 1st Qu.:203.8 ## Median : 195.0 Median : 200.0 Median : 230.0 Median :282.5 ## Mean : 228.2 Mean : 239.6 Mean : 268.7 Mean :310.6 ## 3rd Qu.: 281.2 3rd Qu.: 280.0 3rd Qu.: 325.0 3rd Qu.:385.0 ## Max. :1320.0 Max. :1200.0 Max. :1105.0 Max. :880.0 ## AGE_50_TO_54 AGE_55_TO_59 AGE_60_TO_64 AGE_65_TO_69 ## Min. : 0.0 Min. : 0.0 Min. : 0 Min. : 0.0 ## 1st Qu.:203.8 1st Qu.:175.0 1st Qu.:140 1st Qu.:115.0 ## Median :280.0 Median :240.0 Median :220 Median :157.5 ## Mean :300.3 Mean :257.7 Mean :229 Mean :174.2 ## 3rd Qu.:375.0 3rd Qu.:325.0 3rd Qu.:295 3rd Qu.:221.2 ## Max. :740.0 Max. :625.0 Max. :540 Max. :625.0 ## AGE_70_TO_74 AGE_75_TO_79 AGE_80_TO_84 AGE_MORE_85 ## Min. : 0.0 Min. : 0.00 Min. : 0.00 Min. : 0.00 ## 1st Qu.: 90.0 1st Qu.: 68.75 1st Qu.: 50.00 1st Qu.: 35.00 ## Median :130.0 Median :100.00 Median : 77.50 Median : 70.00 ## Mean :139.7 Mean :118.32 Mean : 95.05 Mean : 87.71 ## 3rd Qu.:180.0 3rd Qu.:160.00 3rd Qu.:120.00 3rd Qu.:105.00 ## Max. :540.0 Max. :575.00 Max. :420.00 Max. :400.00 ## geometry ## POLYGON :188 ## epsg:26917 : 0 ## +proj=utm ...: 0 ## ## ## The sf object can be converted into a SpatialPolygonsDataFrame object for use with the spdedp package: Hamilton_CT.sp &lt;- as(Hamilton_CT, &quot;Spatial&quot;) 23.4 Spatial Moving Averages and Simulation In the preceding chapter and activity you learned about spatial weights matrices as a way to define proximity in the analysis of area data. You also used spatial moving averages to explore spatial patterns in area data. Let us briefly revisit these notions. Here, you create a spatial weights matrix for Hamilton CMA census tracts: Hamilton_CT.nb &lt;- poly2nb(pl = Hamilton_CT.sp) Hamilton_CT.w &lt;- nb2listw(Hamilton_CT.nb) The spatial moving averages are calculated as follows: POP_DENSITY.sma &lt;- lag.listw(Hamilton_CT.w, Hamilton_CT$POP_DENSITY) Let us append the spatial moving averages to both the sf and SpatialPolygonsDataFrame objects: Hamilton_CT$POP_DENSITY.sma &lt;- POP_DENSITY.sma Hamilton_CT.sp$POP_DENSITY.sma &lt;- POP_DENSITY.sma The spatial moving average can be used in two ways to explore the spatial pattern of an area variable: as a smoother and by means of a scatterplot, combined with the original variable. 23.5 The Spatial Moving Average as a Smoother First, when mapped, it is essentially a smoothing technique, in that it reduces the amount of variability to make it easier to distinguish the overall pattern. This can be illustrated with the help of a little simulation. To simulate a random spatial variable, we can randomize the observations that we already have, reassigning them at random to areas in the system. This is accomplished as follows: POP_DENSITY_s1 &lt;- sample(Hamilton_CT$POP_DENSITY) Calculate the spatial moving average for this randomized variable: POP_DENSITY_s1.sma &lt;- lag.listw(Hamilton_CT.w, POP_DENSITY_s1) Once that you have seen how to randomize the variable, simulate a total of eight variables, and calculate their spatial moving averages: POP_DENSITY_s2 &lt;- sample(Hamilton_CT$POP_DENSITY) POP_DENSITY_s2.sma &lt;- lag.listw(Hamilton_CT.w, POP_DENSITY_s2) POP_DENSITY_s3 &lt;- sample(Hamilton_CT$POP_DENSITY) POP_DENSITY_s3.sma &lt;- lag.listw(Hamilton_CT.w, POP_DENSITY_s3) POP_DENSITY_s4 &lt;- sample(Hamilton_CT$POP_DENSITY) POP_DENSITY_s4.sma &lt;- lag.listw(Hamilton_CT.w, POP_DENSITY_s4) POP_DENSITY_s5 &lt;- sample(Hamilton_CT$POP_DENSITY) POP_DENSITY_s5.sma &lt;- lag.listw(Hamilton_CT.w, POP_DENSITY_s5) POP_DENSITY_s6 &lt;- sample(Hamilton_CT$POP_DENSITY) POP_DENSITY_s6.sma &lt;- lag.listw(Hamilton_CT.w, POP_DENSITY_s6) POP_DENSITY_s7 &lt;- sample(Hamilton_CT$POP_DENSITY) POP_DENSITY_s7.sma &lt;- lag.listw(Hamilton_CT.w, POP_DENSITY_s7) POP_DENSITY_s8 &lt;- sample(Hamilton_CT$POP_DENSITY) POP_DENSITY_s8.sma &lt;- lag.listw(Hamilton_CT.w, POP_DENSITY_s8) Now, append the spatial moving averages to the dataframes: Hamilton_CT$POP_DENSITY_s1 &lt;- POP_DENSITY_s1 Hamilton_CT$POP_DENSITY_s2 &lt;- POP_DENSITY_s2 Hamilton_CT$POP_DENSITY_s3 &lt;- POP_DENSITY_s3 Hamilton_CT$POP_DENSITY_s4 &lt;- POP_DENSITY_s4 Hamilton_CT$POP_DENSITY_s5 &lt;- POP_DENSITY_s5 Hamilton_CT$POP_DENSITY_s6 &lt;- POP_DENSITY_s6 Hamilton_CT$POP_DENSITY_s7 &lt;- POP_DENSITY_s7 Hamilton_CT$POP_DENSITY_s8 &lt;- POP_DENSITY_s8 Hamilton_CT$POP_DENSITY_s1.sma &lt;- POP_DENSITY_s1.sma Hamilton_CT$POP_DENSITY_s2.sma &lt;- POP_DENSITY_s2.sma Hamilton_CT$POP_DENSITY_s3.sma &lt;- POP_DENSITY_s3.sma Hamilton_CT$POP_DENSITY_s4.sma &lt;- POP_DENSITY_s4.sma Hamilton_CT$POP_DENSITY_s5.sma &lt;- POP_DENSITY_s5.sma Hamilton_CT$POP_DENSITY_s6.sma &lt;- POP_DENSITY_s6.sma Hamilton_CT$POP_DENSITY_s7.sma &lt;- POP_DENSITY_s7.sma Hamilton_CT$POP_DENSITY_s8.sma &lt;- POP_DENSITY_s8.sma To create choropleth maps of the empirical variable and the eight simulated variables using facet_wrap, we first reorganize the data so that all the spatial moving average variables are in a single column, and there is a new column that identifies which variable they correspond to: Hamilton_CT2 &lt;- Hamilton_CT %&gt;% select(POP_DENSITY.sma, POP_DENSITY_s1.sma, POP_DENSITY_s2.sma, POP_DENSITY_s3.sma, POP_DENSITY_s4.sma, POP_DENSITY_s5.sma, POP_DENSITY_s6.sma, POP_DENSITY_s7.sma, POP_DENSITY_s8.sma, geometry) %&gt;% gather(VAR, DENSITY_SMA, -geometry) Now plot: ggplot() + geom_sf(data = Hamilton_CT2, aes(fill = DENSITY_SMA), color = NA) + facet_wrap(~VAR, ncol = 3) + scale_fill_distiller(palette = &quot;YlOrRd&quot;, direction = 1) + # Select palette for colors labs(fill = &quot;Pop Den SMA&quot;) + # Change the label of the legend theme(axis.text.x = element_blank(), axis.text.y = element_blank()) # Remove the axis labels The empirical variable is the map number in the upper left corner. The remaining 8 maps are simulated variables. Would you say the map of the empirical variable is fairly different from the map of the simulated variables? What are the key differences? Perhaps similar insights could be derived from randomizing the original population density variable, instead of the spatial moving average. An additional advantage of the spatial moving average is its use in the development of scatterplots. 23.6 Spatial Moving Average Scatterplots Let us explore the use of spatial moving average scatterplots. First, we will extract the density information from the original sf object, reorganize, and append to Hamilton_CT2 so that we can plot using faceting: Hamilton_CT2$DENSITY &lt;- data.matrix(Hamilton_CT %&gt;% select(POP_DENSITY, POP_DENSITY_s1, POP_DENSITY_s2, POP_DENSITY_s3, POP_DENSITY_s4, POP_DENSITY_s5, POP_DENSITY_s6, POP_DENSITY_s7, POP_DENSITY_s8, geometry) %&gt;% # Extract density variables and geometry gather(VAR, DENSITY, -geometry) %&gt;% select(DENSITY) %&gt;% # Drop VAR from the object st_set_geometry(NULL)) # Drop geometry, turn into dataframe Create the scatterplot of the empirical population density and its spatial moving average, and the scatterplots of the simulated variables and their spatial moving averages for comparison (the plots include the 45 degree line): ggplot(data = Hamilton_CT2, aes(x = DENSITY, y = DENSITY_SMA, color = VAR)) + geom_point() + geom_abline(slope = 1, intercept = 0) + coord_equal() + facet_wrap(~ VAR, ncol = 3, nrow = 3) What difference do you see between the empirical and simulated variables in these scatterplots? Fitting a line to the scatterplots (i.e., adding a regression line), makes the difference between the empirical and simulated variables easier to appreciate. This line would take the following form, with \\(\\beta\\) as the slope of the line, and \\(\\alpha\\) the intercept: \\[ \\overline{x_i} =\\alpha + \\beta x_i \\] Plot the scatterplots with fitted lines: ggplot(data = Hamilton_CT2, aes(x = DENSITY, y = DENSITY_SMA, color = VAR)) + geom_point(alpha = 0.1) + geom_abline(slope = 1, intercept = 0, linetype = &quot;dashed&quot;) + geom_smooth(method = &quot;lm&quot;) + coord_equal() + facet_wrap(~ VAR, ncol = 3, nrow = 3) You will notice that the slope of the line tends to be flat in the simulated variables; this is to be expected, since these variables are spatially random: the values of the variable at \\(i\\) are independent of the values of their local means!. In other words, the possibility of a non-random spatial pattern is low. The empirical variable, on the other hand, has a slope that is much closer to the 45 degree line. This indicates that the values of the variable at \\(i\\) are not independent of their local means: in other words, \\(x_i\\) is correlated with \\(\\overline{x_i}\\), and the possibility of a non-random pattern is high. This phenomenon is called spatial autocorrelation. 23.7 Spatial Autocorrelation and Moran’s \\(I\\) coefficient As seen above, the spatial moving average can provide evidence of the phenomenon of spatial autocorrelation, that is, when a variable displays spatial patterns whereby values at \\(i\\) are not independent of the values of the variable in their neighborhood. A convenient modification to the concept of the spatial moving average is as follows. Instead of using the variable \\(x\\) for the calculation of the spatial moving average, we first center it on the global mean: \\[ z_i = x_i - \\overline{x} \\] In this way, the values of \\(z_i\\) are given in deviations from the mean. By forcing the variable to be centered on the mean, the slope of the fit line is forced to pass through the origin. Calculate the mean-centered version of POP_DENSIT, and then its spatial moving average: df_mean_center_scatterplot &lt;- transmute(Hamilton_CT, Density_z = POP_DENSITY - mean(POP_DENSITY), SMA_z = lag.listw(Hamilton_CT.w, Density_z)) Compare the following two plots. You will see that they are identical, but in the mean-centered one the origin of the axes coincides with the means of \\(x\\) and the spatial moving average: sc1 &lt;- ggplot(data = subset(Hamilton_CT2, VAR == &quot;POP_DENSITY.sma&quot;), aes(x = DENSITY, y = DENSITY_SMA)) + geom_point(alpha = 0.1) + geom_abline(slope = 1, intercept = 0, linetype = &quot;dashed&quot;) + geom_smooth(method = &quot;lm&quot;) + ggtitle(&quot;Population Density&quot;) + coord_equal() sc2 &lt;- ggplot(data = df_mean_center_scatterplot, aes(x = Density_z, y = SMA_z)) + geom_point(alpha = 0.1) + geom_abline(slope = 1, intercept = 0, linetype = &quot;dashed&quot;) + geom_smooth(method = &quot;lm&quot;, formula = y ~ x-1) + ggtitle(&quot;Mean-Centered Population Density&quot;) + coord_equal() grid.arrange(sc1, sc2, ncol = 1) Notice what happens when the variable \\(z_i\\) multiplies its spatial moving average: \\[ z_i\\overline{z_i} = z_i\\sum_{j=1}^n{w_{ij}^{st}z_j} \\] When \\(z_i\\) is above its mean, it is a positive value and negative otherwise. Likewise, when \\(\\overline{z_i}\\) is above its mean, it is a positive value, and negative otherwise. There are four posibilities with respect to the combinations of (relatively) high and low values. Quadrant 1 (high &amp; high): If \\(z_i\\) is above the mean, it is a relatively high value in the distribution (signed positive). If its neighbors are also relatively high values, the spatial moving average will be above the mean, and also signed positive. Their product will be positive (positive times positive equals positive). Quadrant 2 (low &amp; high): If \\(z_i\\) is below the mean, it is a relatively low value in the distribution (signed negative). If its neighbors in contrast are relatively high values, the spatial moving average will be above the mean, and signed positive. Their product will be negative (negative times positive equals negative). Quadrant 3 (low &amp; low): If \\(z_i\\) is below the mean, it is a relatively low value in the distribution (signed negative). If its neighbors are also relatively low values, the spatial moving average will be below the mean, and also signed negative. Their product will be positive (negative times negative equals positive). Quadrant 4: If \\(z_i\\) is above the mean, it is a relatively high value in the distribution (signed positive). If its neighbors are relatively low values, the spatial moving average will be below the mean, and signed negative. Their product will be negative (positive times negative equals negative). These four quadrants are shown in the following plot: ggplot(data = df_mean_center_scatterplot, aes(x = Density_z, y = SMA_z)) + geom_point(color = &quot;gray&quot;) + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + annotate(&quot;text&quot;, label = &quot;Q1: Positive&quot;, x= 2000, y = 2500) + annotate(&quot;text&quot;, label = &quot;Q4: Negative&quot;, x= 2000, y = -2500) + annotate(&quot;text&quot;, label = &quot;Q2: Negative&quot;, x= -2000, y = 2500) + annotate(&quot;text&quot;, label = &quot;Q3: Positive&quot;, x= -2000, y = -2500) + coord_equal() Let us say that we add all such products: \\[ \\sum_{i=1}^n{z_i\\overline{z_i}} = \\sum_{i=1}^n{z_i\\sum_{j=1}^n{w_{ij}^{st}z_j}} \\] The more such products are positive, meaning more dots in Quadrants 1 and 3 in the scatterplot, the larger (and positive) the total sum will be. Likewise, as more such products are negative, meaning more dots in Quadrants 2 and 4, the larger (but negative!) the total sum will be. Either case would be indicative of a pattern. If the sum is positive, this would suggest that high &amp; high values tend to be together, while low &amp; low values also tend to be together. In contrast, if the sum is negative, this would suggest that high values tend to be surrounded by low values, and viceversa. 23.8 Moran’s \\(I\\) and Moran’s Scatterplot Based on the discussion above, let us define the following coefficient, called Moran’s I: \\[ I = \\frac{\\sum_{i=1}^n{z_i\\sum_{j=1}^n{w_{ij}^{st}z_j}}}{\\sum_{i=1}^{n}{z_i^2}} \\] The numerator in this expression is the sum of the products described above. The denominator is the variance of variable \\(x_i\\), and is used here to scale Moran’s \\(I\\) so that it is contained roughly in the interval \\((-1, 1)\\) (the exact bounds depend on the characteristics of the zoning system). Moran’s \\(I\\) is a coefficient of spatial autocorrelation. We can calculate Moran’s \\(I\\) as follows (notice how it is the sum of the products of \\(z\\) by its spatial moving average, divided by the variance): sum(df_mean_center_scatterplot$Density_z * df_mean_center_scatterplot$SMA_z) / sum(df_mean_center_scatterplot$Density_z^2) ## [1] 0.5179736 Since the value is positive, and relatively high, this would suggest a non-random spatial pattern of similar values (i.e., high &amp; high and low &amp; low). Moran’s \\(I\\) is implemented in R in the spdep package, which makes its calculation easy, since you do not have to go manually through the process of calculating the spatial moving averages, etc. The function moran requires as input arguments a variable, a set of spatial weights, the number of zones (\\(n\\)), and the total sum of all weights (termed \\(S_0\\)) - which in the case of row-standardized spatial weights is equal to the number of zones. Therefore: mc &lt;- moran(Hamilton_CT$POP_DENSITY, Hamilton_CT.w, n = 188, S0 = 188) mc$I ## [1] 0.5179736 You can verify that this matches the value calculated above. The kind of scatterplots that we used previously (called Moran’s scatterplots) can also be created easily by means of the moran.plot function: mp &lt;- moran.plot(Hamilton_CT$POP_DENSITY, Hamilton_CT.w) 23.9 Hypothesis Testing for Spatial Autocorrelation As usual, we need some criterion to decide whether the pattern is random. Moran’s \\(I\\) can be used to develop a test of hypothesis. The expected value of Moran’s \\(I\\) under the null hypothesis of spatial independence and its variance have been derived. A test for autocorrelation based on Moran’s \\(I\\) is implemented in the spdep package: moran.test(Hamilton_CT$POP_DENSITY, Hamilton_CT.w) ## ## Moran I test under randomisation ## ## data: Hamilton_CT$POP_DENSITY ## weights: Hamilton_CT.w ## ## Moran I statistic standard deviate = 12.722, p-value &lt; 2.2e-16 ## alternative hypothesis: greater ## sample estimates: ## Moran I statistic Expectation Variance ## 0.517973553 -0.005347594 0.001691977 The null hypothesis is of spatial independence. The \\(p\\)-value is interpreted as the probability of making a mistake by rejecting the null hypothesis. In the present case, the \\(p\\)-value is such a small number that we can reject the null hypothesis with a high degree of confidence. Moran’s \\(I\\) and Moran’s scatterplots are amongst the most widely used tools in the analysis of spatial area data. "],
["activity-11-area-data-iii.html", "Chapter 24 Activity 11: Area Data III 24.1 Practice questions 24.2 Learning objectives 24.3 Suggested reading 24.4 Preliminaries 24.5 Activity", " Chapter 24 Activity 11: Area Data III Remember, you can download the source file for this activity from here. 24.1 Practice questions Answer the following questions: What does the 45 degree line in the scatterplot of spatial moving averages indicate? What is the effect of centering a variable around the mean? In your own words, describe the phenomenon of spatial autocorrelation. What is the null hypothesis in the test of autocorrelation based on Moran’s I? 24.2 Learning objectives In this activity, you will: Calculate Moran’s I coefficient of autocorrelation for area data. Create Moran’s scatterplots. Examine the results of the tests/scatterplots for further insights. Think about ways to decide whether a landscape is random when working with area data. 24.3 Suggested reading O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 7. John Wiley &amp; Sons: New Jersey. 24.4 Preliminaries For this activity you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity. In addition to tidyverse, you will need sf, a package that implements simple features in R (you can learn about sf here) and spdep, a package that implements several spatial statistical methods (you can learn more about it here): library(tidyverse) library(sf) library(spdep) library(geog4ga3) Begin by loading the data that you will use in this activity: data(Hamilton_CT) This is a sf object with census tracts and selected demographic variables for the Hamilton CMA in Canada. You can obtain new (calculated) variables as follows. For instance, to obtain the proportion of residents who are between 20 and 34 years old, and between 35 and 49: Hamilton_CT &lt;- mutate(Hamilton_CT, Prop20to34 = (AGE_20_TO_24 + AGE_25_TO_29 + AGE_30_TO_34)/POPULATION, Prop35to49 = (AGE_35_TO_39 + AGE_40_TO_44 + AGE_45_TO_49)/POPULATION) You can also convert the sf object into a SpatialPolygonsDataFrame object for use with the spdedp package: Hamilton_CT.sp &lt;- as(Hamilton_CT, &quot;Spatial&quot;) You are now ready for the next activity. 24.5 Activity Create a spatial weights matrix for the census tracts in the Hamilton CMA. Use moran.test to test the following variables for autocorrelation: proportion of the population who are 20 to 34 years old, 35 to 49 years old, 50 to 65 years old, and 65 and older. How confident are you deciding whether these variables are not spatially random? What can you say regarding the relative strength of these variables’ spatial patterns? Use moran.plot to create Moran’s scatterplots to complement your tests of spatial autocorrelation. Discuss the patterns that you observe. The scatterplots created using moran.plot include some observations that are labeled with their id and a different symbol. Why do you think these observations are highlighted in such a way? "],
["area-data-iv.html", "Chapter 25 Area Data IV 25.1 Learning objectives 25.2 Suggested readings 25.3 Preliminaries 25.4 Decomposing Moran’s I 25.5 Local Moran’s I and Mapping 25.6 A Quick Note on Functions 25.7 A Concentration approach for Local Analysis of Spatial Association 25.8 A Short Note on Hypothesis Testing 25.9 Detection of Hot and Cold Spots 25.10 Other Resources", " Chapter 25 Area Data IV NOTE: You can download the source files for this book from here. The source files are in the format of R Notebooks. Notebooks are pretty neat, because the allow you execute code within the notebook, so that you can work interactively with the notes. In previous practice/session, you learned about different ways to define proximity for area data, about spatial weights matrices, and how spatial weights matrices could be used to calculate spatial moving averages. If you wish to work interactively with this chapter you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. 25.1 Learning objectives In this practice, you will learn about: Decomposing Moran’s \\(I\\). Local Moran’s \\(I\\) and mapping. A concentration approach for local analysis of spatial association. A short note on hypothesis testing. Detection of hot and cold spots. 25.2 Suggested readings Bailey TC and Gatrell AC (1995) Interactive Spatial Data Analysis, Chapter 7. Longman: Essex. Bivand RS, Pebesma E, and Gomez-Rubio V (2008) Applied Spatial Data Analysis with R, Chapter 9. Springer: New York. Brunsdon C and Comber L (2015) An Introduction to R for Spatial Analysis and Mapping, Chapter 7. Sage: Los Angeles. O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 7. John Wiley &amp; Sons: New Jersey. 25.3 Preliminaries As usual, it is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity: library(tidyverse) library(sf) library(plotly) library(spdep) library(crosstalk) library(geog4ga3) Load the datasets, first the .RData and then the shape file. data(&quot;df1_simulated&quot;) data(&quot;df2_simulated&quot;) These two dataframes are simulated landscapes, one random and one with a strong systematic pattern. Note that the descriptive statistics of both variables are identical.: summary(df1_simulated) ## x y z ## Min. : 1.00 Min. : 1.00 Min. :24.40 ## 1st Qu.:27.00 1st Qu.:19.00 1st Qu.:27.89 ## Median :46.50 Median :33.00 Median :30.33 ## Mean :45.61 Mean :31.63 Mean :34.38 ## 3rd Qu.:66.00 3rd Qu.:45.00 3rd Qu.:38.25 ## Max. :87.00 Max. :61.00 Max. :69.59 summary(df2_simulated) ## x y z ## Min. : 1.00 Min. : 1.00 Min. :24.40 ## 1st Qu.:27.00 1st Qu.:19.00 1st Qu.:27.89 ## Median :46.50 Median :33.00 Median :30.33 ## Mean :45.61 Mean :31.63 Mean :34.38 ## 3rd Qu.:66.00 3rd Qu.:45.00 3rd Qu.:38.25 ## Max. :87.00 Max. :61.00 Max. :69.59 The third dataset is an object of class sf (simple feature) with the census tracts of Hamilton CMA and some selected population variables from the 2011 Census of Canada: data(Hamilton_CT) The sf object can be converted into a SpatialPolygonsDataFrame object for use with the spdedp package: Hamilton_CT.sp &lt;- as(Hamilton_CT, &quot;Spatial&quot;) 25.4 Decomposing Moran’s I Recall from the preceding reading and activity that Moran’s I coefficient of spatial autocorrelation was derived based on the idea of aggregating the products of a (mean-centered) variable by its spatial moving average, and then dividing by the variance: \\[ I = \\frac{\\sum_{i=1}^n{z_i\\sum_{j=1}^n{w_{ij}^{st}z_j}}}{\\sum_{i=1}^{n}{z_i^2}} \\] Also, you will have seen that when plotting Moran’s scatterplot some observations are highlighted. This is because said observations make a particularly large contribution to \\(I\\). It turns out that those contributions are informative in and of themselves, and their analysis can provide more focused information about the spatial pattern. Consider again the variable POP_DENSIT, population density in the Hamilton CMA. Lets create spatial weights for the census tracts in this system: Hamilton_CT.w &lt;- nb2listw(poly2nb(pl = Hamilton_CT.sp)) Although Moran’s scatterplot can be obtained easily with the functionmoran.plot, here we will create the scatterplot manually to have better control of its aspect. First, create a dataframe with the mean-centered variable and scaled variable \\(z_i=(x_i-\\overline{x})/\\sum z_i^2\\), and its spatial moving average. Notice that this includes as well a factor variable Type to identify the type of spatial relationship (Low &amp; Low, if both \\(z_i\\) and its spatial moving average are negative, High &amp; High, if both \\(z_i\\) and its spatial moving average are positive, and Low &amp; High/High &amp; Low otherwise). This is information is useful for mapping the results: Hamilton_CT &lt;- mutate(Hamilton_CT, Z = (POP_DENSITY - mean(POP_DENSITY)) / var(POP_DENSITY), SMA = lag.listw(Hamilton_CT.w, Z), Type = factor(ifelse(Z &lt; 0 &amp; SMA &lt; 0, &quot;LL&quot;, ifelse(Z &gt; 0 &amp; SMA &gt; 0, &quot;HH&quot;, &quot;HL/LH&quot;)))) Next, create the scatterplot and a choropleth map of the population density. The package plotly is used to create interactive plots. Read more about how to visualize geospatial information with plotly here. The package crosstalk lets us link two plots for brushing. First, create a SharedData object to link two plots: #Create a shared data object for brushing df_msc.sd &lt;- SharedData$new(Hamilton_CT) The function bscols (for bootstrap columns) is used to array two plotly objects; the first of these is a scatterplot, and the second is a choropleth map of population density. bscols( plot_ly(df_msc.sd) %&gt;% add_markers(x = ~Z, y = ~SMA, color = ~POP_DENSITY, size = ~(Z * SMA), colors = &quot;YlOrRd&quot;) %&gt;% hide_colorbar() %&gt;% highlight(&quot;plotly_selected&quot;, persistent = TRUE), plot_ly(df_msc.sd) %&gt;% add_sf(split = ~TRACT, color = ~POP_DENSITY, colors = &quot;YlOrRd&quot;, showlegend = FALSE) %&gt;% hide_colorbar() %&gt;% highlight(dynamic = TRUE, persistent = TRUE) ) The darker colors are zones with higher population densities. The size of the dots in the scatterplot indicates the contributions of the zone to Moran’s \\(I\\). The darker colors in the choropleth map are higher population densities. The plots are linked for brushing: try selecting groups of dots in the scatterplot (double click to clear a selection). Change the color for brushing to select a different group of dots. Can you identify in the map the zones that most contribute to Moran’s \\(I\\)? The direct relationship between the dots in the scatterplot and the values of the variable in the map suggest the following decomposition of Moran’s \\(I\\). 25.5 Local Moran’s I and Mapping A possible decomposition of Moran’s \\(I\\) into local components is as follows (see Anselin 1995) (Available here): \\[ I_i = \\frac{z_i}{m_2}\\sum_{j=1}^n{w_{ij}^{st}z_j} \\] where \\(z_i\\) is a mean-centered variable, and: \\[ m_2 = \\sum_{i=1}^n{z_i^2} \\] is its variance. It is straightforward to see that: \\[ I = \\sum_{i=1}^n{I_i} \\] The above shows how the local Moran’s \\(I\\) coefficients can be aggregated to the global coefficient. An advantage of the local decomposition described here is that it allows the analyst to map the statistic to better understand the spatial pattern. The local version of Moran’s \\(I\\) is implemented in spdep as localmoran, and can be called with a variable and a set of spatial weights as arguments: POP_DENSITY.lm &lt;- localmoran(Hamilton_CT$POP_DENSITY, Hamilton_CT.w) The value (output) of the function is a matrix with local Moran’s \\(I\\) coefficients, and their corresponding expected values and variances (used for hypothesis testing; more on this next). You can check the summary to verify the contents: summary(POP_DENSITY.lm) ## Ii E.Ii Var.Ii ## Min. :-0.62144 Min. :-0.005348 Min. :0.06421 ## 1st Qu.: 0.00478 1st Qu.:-0.005348 1st Qu.:0.13340 ## Median : 0.12523 Median :-0.005348 Median :0.15647 ## Mean : 0.51797 Mean :-0.005348 Mean :0.16681 ## 3rd Qu.: 0.59384 3rd Qu.:-0.005348 3rd Qu.:0.18876 ## Max. : 8.30454 Max. :-0.005348 Max. :0.47938 ## Z.Ii Pr(z &gt; 0) ## Min. :-1.67885 Min. :0.00000 ## 1st Qu.: 0.02345 1st Qu.:0.07352 ## Median : 0.33935 Median :0.36718 ## Mean : 1.32117 Mean :0.31317 ## 3rd Qu.: 1.45104 3rd Qu.:0.49065 ## Max. :19.12671 Max. :0.95341 Similar to the global version of Moran’s \\(I\\), hypothesis testing can be conducted by comparing the empirical statistic to its distribution under the null hypothesis of spatial independence. The function localmoran reports p-values to this end. For further exploration, append the local statistics to your dataframe: Hamilton_CT &lt;- left_join(Hamilton_CT, data.frame(TRACT = Hamilton_CT$TRACT, POP_DENSITY.lm)) ## Joining, by = &quot;TRACT&quot; ## Warning: Column `TRACT` joining character vector and factor, coercing into ## character vector Hamilton_CT &lt;- rename(Hamilton_CT, p.val = Pr.z...0.) Now it is possible to map the local statistics: plot_ly(Hamilton_CT) %&gt;% add_sf(split = ~(p.val &lt; 0.05), color = ~Type, colors = c(&quot;red&quot;, &quot;khaki1&quot;, &quot;dodgerblue&quot;, &quot;dodgerblue4&quot;)) The map above shows whether population density in a zone is high, surrounded by other zones with high population densities (HH), or low, surrounded by zones that also have low population density (LL). Other zones have either low population densities and are surrounded by zones with high population density, or viceversa (HL/LH). Click on the legend to filter by category of TRUE-FALSE and HH-LL-HL/LH. This map allows you to identify what we could call the downtown core (from the perspective of population density), and the most suburban-rural census tracts in the Hamilton CMA. While mapping \\(I_i\\) or their corresponding p-values is straightforward, I personally find it more useful to map whether the zones are of type HH, LH, or HL/LH. Since such maps are not (to the best of my knowledge) the output of an existing function in an R package, so we will create one here. localmoran.map &lt;- function(p = p, listw = listw, VAR = VAR, by = by){ require(tidyverse) require(spdep) require(plotly) df_msc &lt;- transmute(p, key = p[[by]], Z = (p[[VAR]] - mean(p[[VAR]])) / var(p[[VAR]]), SMA = lag.listw(listw, Z), Type = factor(ifelse(Z &lt; 0 &amp; SMA &lt; 0, &quot;LL&quot;, ifelse(Z &gt; 0 &amp; SMA &gt; 0, &quot;HH&quot;, &quot;HL/LH&quot;)))) local_I &lt;- localmoran(p[[VAR]], listw) df_msc &lt;- left_join(df_msc, data.frame(key = p[[by]], local_I)) df_msc &lt;- rename(df_msc, p.val = Pr.z...0.) plot_ly(df_msc) %&gt;% add_sf(split = ~(p.val &lt; 0.05), color = ~Type, colors = c(&quot;red&quot;, &quot;khaki1&quot;, &quot;dodgerblue&quot;, &quot;dodgerblue4&quot;)) } Notice how this function simply replicates the steps that we followed earlier to create the map with the results of the local Moran’s \\(I\\)s. To use this function you need as inputs an object of class sf, a listw object with spatial weights, and to define the variable of interest and a unique identifier for the areas (such as their tract identifiers). For example: localmoran.map(Hamilton_CT, Hamilton_CT.w, &quot;POP_DENSITY&quot;, by = &quot;TRACT&quot;) There, the function creates the map as desired. 25.6 A Quick Note on Functions Once that you know the steps needed to complete a task, if the task needs to be repeated many times possibly using different inputs, a function is a way of packing those instructions in a convenient way. That is all. 25.7 A Concentration approach for Local Analysis of Spatial Association The local version of Moran’s I is one of the most widely used tools of a family of measures called Local Statistics of Spatial Association or LISA. It is not the only one, however. In this section, we will see an alternative way of exploring spatial patterns locally, by means of a concentration approach. Imagine a landscape with a variable that can be measured in a ratio scale with a true zero point (say, population, income, a contaminant, or property values, variables that do not take negative values and the value of zero indicates complete absence). Imagine that you stand at a given location on that landscape and survey your surroundings. If your surroundings look very similar to you (i.e., if their elevation is similar, relative to the rest of the landscape), you would take that as evidence of a spatial pattern, at least locally. This is the idea behind spatial autocorrelation analysis. As an alternative, imagine for instance that the variable of interest is, say, personal income. You might ask “how much of the regional wealth can be found in my neighborhood?” (or, if you prefer, imagine that the variable is a contaminant, and your question would be, how much of it is around here?) Imagine now that personal income is spatially random. What would you expect the share of the wealth to be in your neighborhood? Would that share change if you moved to any other location? Lets elaborate this thought experiment. Take the df1 dataframe. The total sum of this variable in the region is 12,034.34. See: sum(df1_simulated$z) ## [1] 12034.34 The following is an interactive plot of variable z in the sample dataframe df1. This variable is spatially random: plot_ly(df1_simulated, x = ~x, y = ~y, z = ~z, marker = list(color = ~z, colorscale = c(&#39;#FFE1A1&#39;, &#39;#683531&#39;), showscale = TRUE)) %&gt;% add_markers() Imagine that you stand at coordinates x = 53 and y = 34 (lets call this the focal point), and you survey the landscape within a radius r of 10 (units of distance) of this location. How much wealth is concentrated in the neighborhood of the focal point? Lets see: xy0 &lt;- c(53, 34) r &lt;- 10 df1_xy0 &lt;- subset(df1_simulated, sqrt((x - xy0[1])^2 + (y - xy0[2])^2) &lt; r) sum(df1_xy0$z) ## [1] 832.0156 Recall that the total of the variable for the region is 12,034.34. If you change the radius r to a very large number, the concentration of the variable will simply become the total sum for the region. Essentially, the whole region is the “neighborhood” of the focal point. Try it. Now, for a fixed radius, change the focal point, and see how much the concentration of the variable changes for its neighborhood. How does the concentration of the variable by focal point? Lets repeat the thought experiment but now with the landscape shown in the following figure: plot_ly(df2_simulated, x = ~x, y = ~y, z = ~z, marker = list(color = ~z, colorscale = c(&#39;#FFE1A1&#39;, &#39;#683531&#39;), showscale = TRUE)) %&gt;% add_markers() Imagine that you stand at the focal point with coordinates x = 53 and y = 34. Can you identify the point in the plot? If you surveyed the neighborhood, what would be the concentration of wealth there? How would that change as you visited different focal points? Lets see (again, recall that the total of the variable for the whole region is 12,034.34): xy0 &lt;- c(71, 10) r &lt;- 10 df2_xy0 &lt;- subset(df2_simulated, sqrt((x - xy0[1])^2 + (y - xy0[2])^2) &lt; r) sum(df2_xy0$z) ## [1] 542.8224 Change the focal point. How does the concentration of the variable change? Lets define the following measure of local concentration (see Getis and Ord, 1992): \\[ G_i^*(d)=\\frac{\\sum_{j=1}^n{w_{ij}x_j}}{\\sum_{i=i}^{n}x_{i}} \\] Notice that the spatial weights are not row-standardized, and in fact must be a binary variable as follows: \\[ w_{ij}=\\bigg\\{\\begin{array}{l l} 1\\text{ if } d_{ij}\\leq d\\\\ 0\\text{ otherwise}\\\\ \\end{array} \\] This is because in this measure of concentration, we do not calculate the spatial moving average for the neighborhood, but the total of the variable in the neighborhood. A variant of this statistic removes from the sum the value of the variable at i: \\[ G_i(d)=\\frac{\\sum_{j\\neq i}^n{w_{ij}x_j}}{\\sum_{i=i}^{n}x_{i}} \\] I do not find this definition to be particularly useful. I suspect it was defined to resemble Moran’s I where an area is not it’s own neighbor - which makes sense in an autocorrelation sense (an area is perfectly autocorrelated with itself). In a concentration approach, not using the value at \\(i\\) is less appealing. As with the local version of Moran’s I, it is possible to map the statistic to better understand the spatial pattern. The \\(G_i(d)\\) statistic is implemented in spdep as localG, and can be called with a variable and a set of spatial weights as arguments. Lets calculate this statistic for the two datasets in the example above. This requires that we create binary spatial weights. Begin by creating neighbors by distance: xy_coord &lt;- cbind(df1_simulated$x, df1_simulated$y) dn10 &lt;- dnearneigh(xy_coord, 0, 10) Two differences with the procedure that you used before to create spatial weights is that we wish to include the observation at \\(i\\) as well (so include.self(), and the style of the matrix is “B” (for binary): wb10 &lt;- nb2listw(include.self(dn10), style = &quot;B&quot;) The local statistics can be obtained as follows: df1.lg &lt;- localG(df1_simulated$z, wb10) The value (output) of the function is a ’vector localG object with normalized local statistics. Normalized means that the mean under the null hypothesis has been substracted and the result has been divided by the variance under the null. Normalized statistics can be compared to the standard normal distribution for hypothesis testing. You can check the summary to verify the contents: summary(df1.lg) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -1.6345 -0.5085 0.1401 0.0657 0.5911 2.6638 Lets add p-values to this: df1.lg &lt;- as.numeric(df1.lg) df1.lg &lt;- data.frame(Gstar = df1.lg, p.val = 2 * pnorm(abs(df1.lg), lower.tail = FALSE)) How many of the p-values are less than the conventional decision cutoff of 0.05? Now the second example: df2.lg &lt;- localG(df2_simulated$z, wb10) summary(df2.lg) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -4.2400 -2.6791 -1.3999 0.1503 2.3938 12.2401 Adding p-values: df2.lg &lt;- as.numeric(df2.lg) df2.lg &lt;- data.frame(Gstar = df2.lg, p.val = 2 * pnorm(abs(df2.lg), lower.tail = FALSE)) If we append the results of the analysis to the dataframe, we can plot the results for further exploration. We will classify the results by their type, in this case high and low concentrations: df2 &lt;- cbind(df2_simulated[,1:3],df2.lg) df2 &lt;- mutate(df2, Type = factor(ifelse(Gstar &lt; 0 &amp; p.val &lt;= 0.05, &quot;Low Concentration&quot;, ifelse(Gstar &gt; 0 &amp; p.val &lt;= 0.05, &quot;High Concentration&quot;, &quot;Not Signicant&quot;)))) And then the plot: plot_ly(df2, x = ~x, y = ~y, z = ~z, color = ~Type, colors = c(&quot;red&quot;, &quot;blue&quot;, &quot;gray&quot;), marker = list()) %&gt;% add_markers() What kind of pattern do you observe? 25.8 A Short Note on Hypothesis Testing Local tests as introduced above are affected by an issue called multiple testing. Typically, when attempting to assess the significance of a statistic, a level of significance is adopted (conventionally 0.05, for instance). When working with local statistics, we typically conduct many tests of hypothesis simultaneously (in the example above, one for each observation). A risk when conducting a large number of tests is that some of them might appear significant purely by chance! The more tests we conduct, the more likely that at least a few of them will be significant by chance. For instance, in the preceding example the variable in df1 was spatially random, and yet a few observations had p-values smaller than 0.05. What this suggests is that some correction to the level of significance used is needed. A crude rule to make this adjustment in called Bonferroni correction. This correction is as follows: \\[ \\alpha_B = \\frac{\\alpha_{nominal}}{m} \\] where \\(\\alpha_{nominal}\\) is the nominal level of significance, \\(\\alpha_B\\) is the adjusted level of significance, and \\(m\\) is the number of simultaneous tests. This correction requires that each test be evaluated at a lower level of significance \\(\\alpha_B\\) in order to to achieve a nominal level of significance of 0.05. If we apply this correction to the analysis above, we see that instead of 0.05, the p-value needed for significance is much lower: alpha_B &lt;- 0.05/nrow(df1_simulated) alpha_B ## [1] 0.0001428571 You can verify now that no observations in df1 show up as significant: sum(df1.lg$p.val &lt;= alpha_B) ## [1] 0 If we examine the variable in df2: df2 &lt;- mutate(df2, Type = factor(ifelse(Gstar &lt; 0 &amp; p.val &lt;= alpha_B, &quot;Low Concentration&quot;, ifelse(Gstar &gt; 0 &amp; p.val &lt;= alpha_B, &quot;High Concentration&quot;, &quot;Not Signicant&quot;)))) plot_ly(df2, x = ~x, y = ~y, z = ~z, color = ~Type, colors = c(&quot;red&quot;, &quot;blue&quot;, &quot;gray&quot;), marker = list()) %&gt;% add_markers() You will see that fewer observations are significant, but it is still possible to detect two regions of high concentration, and two of low concentration. Bonferroni correction is known to be overly strict, and sharper approaches exist to correct for multiple testing. Between the nominal level (no correction) and Bonferroni correction, it is still possible to assess the gravity of the issue of multiple comparisons. Observations that are flagged as significant with the Bonferroni correction, will also be significant under more refined corrections, so it provides a most conservative decision rule. 25.9 Detection of Hot and Cold Spots As the examples above illustrate, local statistics can be very useful in detecting what might be termed “hot” and “cold” spots. A hot spot is a group of observations that are significantly high, whereas a cold spot is a group of observations that are significantly low. There are many different applications where hot/cold spot detection is important. For instance, in many studies of urban form, it is important to identify centers and subcenters - by population, by property values, by incidence of trips, and so on. In spatial criminology, detecting hot spots of crime can help with prevention and law enforcement efforts. In environmental studies, remediation efforts can be greatly assisted by identification of hot areas. And so on. 25.10 Other Resources Check a cool app that illustrates the \\(G_i^*\\) statistic here References "],
["activity-13-area-data-iv.html", "Chapter 26 Activity 13: Area Data IV 26.1 Practice questions 26.2 Learning objectives 26.3 Suggested reading 26.4 Preliminaries 26.5 Activity", " Chapter 26 Activity 13: Area Data IV 26.1 Practice questions Answer the following questions: How are row-standardized and binary spatial weights interpreted? What is the reason for using a Bonferroni correction for multiple tests? What types of spatial patterns can the local version of Moran’s I detect? What types of spatial patterns can the \\(G_i(d)\\) statistic detect? What is the utility of detecting hot and cold spatial spots? 26.2 Learning objectives In this activity, you will: Calculate Moran’s I coefficient of autocorrelation for area data. Create Moran’s scatterplots. Examine the results of the tests/scatterplots for further insights. Think about ways to decide whether a landscape is random when working with area data. 26.3 Suggested reading O’Sullivan D and Unwin D (2010) Geographic Information Analysis, 2nd Edition, Chapter 7. John Wiley &amp; Sons: New Jersey. 26.4 Preliminaries For this activity you will need the following: An R markdown notebook version of this document (the source file). A package called geog4ga3. It is good practice to clear the working space to make sure that you do not have extraneous items there when you begin your work. The command in R to clear the workspace is rm (for “remove”), followed by a list of items to be removed. To clear the workspace from all objects, do the following: rm(list = ls()) Note that ls() lists all objects currently on the worspace. Load the libraries you will use in this activity. In addition to tidyverse, you will need sf, a package that implements simple features in R (you can learn about sf here) and spdep, a package that implements several spatial statistical methods (you can learn more about it here): library(tidyverse) library(sf) library(spdep) library(geog4ga3) Begin by loading the data that you will use in this activity: data(Hamilton_CT) This is a sf object with census tracts and selected demographic variables for the Hamilton CMA in Canada. You can obtain new (calculated) variables as follows. For instance, to obtain the proportion of residents who are between 20 and 34 years old, and between 35 and 49: Hamilton_CT &lt;- mutate(Hamilton_CT, Prop20to34 = (AGE_20_TO_24 + AGE_25_TO_29 + AGE_30_TO_34)/POPULATION, Prop35to49 = (AGE_35_TO_39 + AGE_40_TO_44 + AGE_45_TO_49)/POPULATION) You can also convert the sf object into a SpatialPolygonsDataFrame object for use with the spdedp package: Hamilton_CT.sp &lt;- as(Hamilton_CT, &quot;Spatial&quot;) This function is used to create local Moran maps: localmoran.map &lt;- function(p = p, listw = listw, VAR = VAR, by = by){ require(tidyverse) require(spdep) require(plotly) df_msc &lt;- transmute(p, key = p[[by]], Z = (p[[VAR]] - mean(p[[VAR]])) / var(p[[VAR]]), SMA = lag.listw(listw, Z), Type = factor(ifelse(Z &lt; 0 &amp; SMA &lt; 0, &quot;LL&quot;, ifelse(Z &gt; 0 &amp; SMA &gt; 0, &quot;HH&quot;, &quot;HL/LH&quot;)))) local_I &lt;- localmoran(p[[VAR]], listw) df_msc &lt;- left_join(df_msc, data.frame(key = p[[by]], local_I)) df_msc &lt;- rename(df_msc, p.val = Pr.z...0.) plot_ly(df_msc) %&gt;% add_sf(split = ~(p.val &lt; 0.05), color = ~Type, colors = c(&quot;red&quot;, &quot;khaki1&quot;, &quot;dodgerblue&quot;, &quot;dodgerblue4&quot;)) } This function is used to create \\(G_i^*\\) maps: gistar.map &lt;- function(p = p, listw = listw, VAR = VAR, by = by){ require(tidyverse) require(spdep) require(sf) require(plotly) p &lt;- mutate(p, key = p[[by]]) df.lg &lt;- localG(p[[VAR]], listw) df.lg &lt;- as.numeric(df.lg) df.lg &lt;- data.frame(Gstar = df.lg, p.val = 2 * pnorm(abs(df.lg), lower.tail = FALSE)) df.lg &lt;- mutate(df.lg, Type = factor(ifelse(Gstar &lt; 0 &amp; p.val &lt;= 0.05, &quot;Low Concentration&quot;, ifelse(Gstar &gt; 0 &amp; p.val &lt;= 0.05, &quot;High Concentration&quot;, &quot;Not Signicant&quot;)))) p &lt;- left_join(p, data.frame(key = p[[by]], df.lg)) plot_ly(p) %&gt;% add_sf(split = ~(p.val &lt; 0.05), color = ~Type, colors = c(&quot;red&quot;, &quot;dodgerblue&quot;, &quot;gray&quot;)) } Create spatial weights. By contiguity: Hamilton_CT.w &lt;- nb2listw(poly2nb(pl = Hamilton_CT.sp)) Binary, by distance (3 km threshold) including self. Hamilton_CT.3knb &lt;- Hamilton_CT.sp %&gt;% coordinates() %&gt;% dnearneigh(d1 = 0, d2 = 3) Hamilton_CT.3kw &lt;- nb2listw(include.self(Hamilton_CT.3knb), style = &quot;B&quot;) You are now ready for the next activity. 26.5 Activity Create local Moran maps for the population and proportion of population in the age group 20-34. What is the difference between using population (absolute) and proportion of population (rate)? Is there a reason to prefer either variable in analysis? Discuss. Use the \\(G_i^*\\) statitic to analyze the population and proportion of population in the age group 20-34. What is the difference between using population (absolute) and proportion of population (rate)? Is there a reason to prefer either variable in analysis? Discuss. Now create local Moran maps for the population and population density in the age group 20-34. What is the difference between using population (absolute) and population density (rate)? More generally, what do you think should guide the decision of whether to analyze variables as absolute values or rates? "]
]
